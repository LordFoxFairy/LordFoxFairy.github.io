<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='第4章：推理模型专题 (Reasoning Models: O1 & DeepSeek-R1)# 当前最前沿的赛道。从 OpenAI 的闭源 o1 到 DeepSeek 的开源 R1，大模型终于学会了"慢思考"。本章深入探讨推理模型的理论基础、核心技术与实战应用。
目录# 一、推理模型的理论基础 二、OpenAI o1 的技术猜想 三、DeepSeek-R1 的技术解密 四、推理时计算增强实战 五、验证器 (Verifier) 训练 本章小结 一、推理模型的理论基础# 1. 什么是推理模型?# 推理模型(Reasoning Model)是指能够进行多步骤逻辑推理的大语言模型。与传统的"快速响应"模式不同,推理模型会：
展开思维链 - 将复杂问题分解为多个子问题 自我验证 - 检查中间步骤的正确性 回溯修正 - 发现错误时重新推理 这种能力在数学、代码、逻辑推理等任务上至关重要。
快速推理 vs 深度推理# 特性 快速推理 (Fast Thinking) 深度推理 (Slow Thinking) 响应时间 秒级 分钟级 思考步骤 1-3步 10-100+步 适用场景 闲聊、翻译、摘要 数学、编程、逻辑推理 代表模型 GPT-4、Claude-3 O1、R1 成本 低 高(10-50倍) graph LR A[用户问题] --> B{是否需要深度推理?} B -->|否| C[快速推理模型<br/>直接生成答案] B -->|是| D[推理模型<br/>展开思维链] D --> E[步骤1: 理解问题] E --> F[步骤2: 制定方案] F --> G[步骤3: 执行计算] G --> H[步骤4: 验证答案] H --> I{正确?} I -->|否| F I -->|是| J[输出最终答案]2. Chain-of-Thought (CoT) 的数学原理# CoT 的核心思想是:让模型输出中间推理步骤,而不是直接给出答案。
'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://LordFoxFairy.github.io/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC4%E7%AB%A0_%E6%8E%A8%E7%90%86%E6%A8%A1%E5%9E%8B%E4%B8%93%E9%A2%98/"><meta property="og:site_name" content="LordFoxFairy的笔记本"><meta property="og:title" content="第4章 推理模型专题"><meta property="og:description" content='第4章：推理模型专题 (Reasoning Models: O1 & DeepSeek-R1)# 当前最前沿的赛道。从 OpenAI 的闭源 o1 到 DeepSeek 的开源 R1，大模型终于学会了"慢思考"。本章深入探讨推理模型的理论基础、核心技术与实战应用。
目录# 一、推理模型的理论基础 二、OpenAI o1 的技术猜想 三、DeepSeek-R1 的技术解密 四、推理时计算增强实战 五、验证器 (Verifier) 训练 本章小结 一、推理模型的理论基础# 1. 什么是推理模型?# 推理模型(Reasoning Model)是指能够进行多步骤逻辑推理的大语言模型。与传统的"快速响应"模式不同,推理模型会：
展开思维链 - 将复杂问题分解为多个子问题 自我验证 - 检查中间步骤的正确性 回溯修正 - 发现错误时重新推理 这种能力在数学、代码、逻辑推理等任务上至关重要。
快速推理 vs 深度推理# 特性 快速推理 (Fast Thinking) 深度推理 (Slow Thinking) 响应时间 秒级 分钟级 思考步骤 1-3步 10-100+步 适用场景 闲聊、翻译、摘要 数学、编程、逻辑推理 代表模型 GPT-4、Claude-3 O1、R1 成本 低 高(10-50倍) graph LR A[用户问题] --> B{是否需要深度推理?} B -->|否| C[快速推理模型<br/>直接生成答案] B -->|是| D[推理模型<br/>展开思维链] D --> E[步骤1: 理解问题] E --> F[步骤2: 制定方案] F --> G[步骤3: 执行计算] G --> H[步骤4: 验证答案] H --> I{正确?} I -->|否| F I -->|是| J[输出最终答案]2. Chain-of-Thought (CoT) 的数学原理# CoT 的核心思想是:让模型输出中间推理步骤,而不是直接给出答案。'><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="notebooks"><meta itemprop=name content="第4章 推理模型专题"><meta itemprop=description content='第4章：推理模型专题 (Reasoning Models: O1 & DeepSeek-R1)# 当前最前沿的赛道。从 OpenAI 的闭源 o1 到 DeepSeek 的开源 R1，大模型终于学会了"慢思考"。本章深入探讨推理模型的理论基础、核心技术与实战应用。
目录# 一、推理模型的理论基础 二、OpenAI o1 的技术猜想 三、DeepSeek-R1 的技术解密 四、推理时计算增强实战 五、验证器 (Verifier) 训练 本章小结 一、推理模型的理论基础# 1. 什么是推理模型?# 推理模型(Reasoning Model)是指能够进行多步骤逻辑推理的大语言模型。与传统的"快速响应"模式不同,推理模型会：
展开思维链 - 将复杂问题分解为多个子问题 自我验证 - 检查中间步骤的正确性 回溯修正 - 发现错误时重新推理 这种能力在数学、代码、逻辑推理等任务上至关重要。
快速推理 vs 深度推理# 特性 快速推理 (Fast Thinking) 深度推理 (Slow Thinking) 响应时间 秒级 分钟级 思考步骤 1-3步 10-100+步 适用场景 闲聊、翻译、摘要 数学、编程、逻辑推理 代表模型 GPT-4、Claude-3 O1、R1 成本 低 高(10-50倍) graph LR A[用户问题] --> B{是否需要深度推理?} B -->|否| C[快速推理模型<br/>直接生成答案] B -->|是| D[推理模型<br/>展开思维链] D --> E[步骤1: 理解问题] E --> F[步骤2: 制定方案] F --> G[步骤3: 执行计算] G --> H[步骤4: 验证答案] H --> I{正确?} I -->|否| F I -->|是| J[输出最终答案]2. Chain-of-Thought (CoT) 的数学原理# CoT 的核心思想是:让模型输出中间推理步骤,而不是直接给出答案。'><meta itemprop=wordCount content="1679"><title>第4章 推理模型专题 | LordFoxFairy的笔记本</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://LordFoxFairy.github.io/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC4%E7%AB%A0_%E6%8E%A8%E7%90%86%E6%A8%A1%E5%9E%8B%E4%B8%93%E9%A2%98/><link rel=stylesheet href=/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG+T2l66Bw7pV8=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.a7a11a812549b6c20d4eeaf4a5a8317847527505f7a0ad3e6824fb320b3128a8.js integrity="sha256-p6EagSVJtsINTur0pagxeEdSdQX3oK0+aCT7MgsxKKg=" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-notebooks"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>LordFoxFairy的笔记本</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-8410cdd8ef137d6cb143c08e6db6ba10 class=toggle>
<label for=section-8410cdd8ef137d6cb143c08e6db6ba10 class=flex><a role=button>LangChain笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%9F%BA%E7%A1%80%E8%AE%A4%E7%9F%A5/>第一篇 基础认知</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E5%AE%9E%E6%88%98/>第二篇 快速上手实战</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AF%87-langgraph-%E6%B7%B1%E5%85%A5/>第三篇 LangGraph 深入</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-rag%E5%9F%BA%E7%A1%80%E7%AF%87langchain%E7%AF%87/>第四篇 RAG基础篇(LangChain篇)</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-rag%E5%9F%BA%E7%A1%80%E7%AF%87llamaindex%E7%AF%87/>第四篇 RAG基础篇(LlamaIndex篇)</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AF%87-rag%E9%AB%98%E7%BA%A7%E7%AF%87langchain%E7%AF%87/>第五篇 RAG高级篇(LangChain篇)</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AF%87-rag%E9%AB%98%E7%BA%A7%E7%AF%87llamaindex%E7%AF%87/>第五篇 RAG高级篇(LlamaIndex篇)</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AF%87-%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/>第六篇 文档处理与数据清洗</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E7%AF%87-deep-agents/>第七篇 Deep Agents</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AF%87-middleware-%E5%B7%A5%E7%A8%8B%E5%8C%96/>第八篇 Middleware 工程化</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B9%9D%E7%AF%87-agent-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/>第九篇 Agent 架构设计</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%8D%81%E7%AF%87-%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%9B%91%E6%8E%A7%E8%AF%84%E4%BC%B0/>第十篇 生产实践与监控评估</a></li><li><input type=checkbox id=section-a3e9b1811e5a21dbfddb0753f565cedb class=toggle>
<label for=section-a3e9b1811e5a21dbfddb0753f565cedb class=flex><a role=button>assets</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li><li><input type=checkbox id=section-9a64553a000534ad3c81a611c6c29ec2 class=toggle>
<label for=section-9a64553a000534ad3c81a611c6c29ec2 class=flex><a role=button>code</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><input type=checkbox id=section-6fad2589acfdd5d6a1fb55beb392fb77 class=toggle>
<label for=section-6fad2589acfdd5d6a1fb55beb392fb77 class=flex><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/code/fasta2a/>fasta2a</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li></ul></li></ul></li><li><input type=checkbox id=section-ce33306d44f9ed4d296b9a79329bed1c class=toggle>
<label for=section-ce33306d44f9ed4d296b9a79329bed1c class=flex><a role=button>图像算法笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AF%87_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/>第一篇 机器学习基础</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/>第二篇 深度学习基础</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AF%87_%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/>第三篇 计算机视觉核心技术</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8Eyolo%E7%B3%BB%E5%88%97/>第四篇 目标检测与YOLO系列</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AF%87_%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/>第五篇 图像分割</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AF%87_%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/>第六篇 生成模型</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E7%AF%87_%E8%A7%86%E8%A7%89%E5%A4%A7%E6%A8%A1%E5%9E%8B/>第七篇 视觉大模型</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AF%87_%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5/>第八篇 生产实践</a></li></ul></li><li><input type=checkbox id=section-77f5db9e44a9af6dab4403b49a65334f class=toggle checked>
<label for=section-77f5db9e44a9af6dab4403b49a65334f class=flex><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/>大模型笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><input type=checkbox id=section-db59738de306cbbe384ad7fbd5cf11b5 class=toggle>
<label for=section-db59738de306cbbe384ad7fbd5cf11b5 class=flex><a role=button>第一部分：大语言模型基础</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/%E7%AC%AC1%E7%AB%A0_%E5%88%9D%E8%AF%86%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/>第1章 初识大语言模型</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/%E7%AC%AC2%E7%AB%A0_%E4%B8%8E%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%AF%9D%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/>第2章 与模型对话：提示工程基础</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/%E7%AC%AC3%E7%AB%A0_%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%88%86%E8%AF%8D%E4%B8%8E%E5%B5%8C%E5%85%A5/>第3章 语言的基石：分词与嵌入</a></li></ul></li><li><input type=checkbox id=section-30b17899e420f6a53aa6e578440dd132 class=toggle>
<label for=section-30b17899e420f6a53aa6e578440dd132 class=flex><a role=button>第二部分：Transformer架构揭秘</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86transformer%E6%9E%B6%E6%9E%84%E6%8F%AD%E7%A7%98/%E7%AC%AC1%E7%AB%A0_transformer%E6%A0%B8%E5%BF%83%E6%8F%AD%E7%A7%98/>第1章 Transformer核心揭秘</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86transformer%E6%9E%B6%E6%9E%84%E6%8F%AD%E7%A7%98/%E7%AC%AC2%E7%AB%A0_%E6%A8%A1%E5%9E%8B%E5%AE%B6%E6%97%8F%E8%B0%B1%E7%B3%BB%E4%BB%8E%E7%BC%96%E7%A0%81%E5%99%A8%E5%88%B0%E8%A7%A3%E7%A0%81%E5%99%A8/>第2章 模型家族谱系：从编码器到解码器</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86transformer%E6%9E%B6%E6%9E%84%E6%8F%AD%E7%A7%98/%E7%AC%AC3%E7%AB%A0_%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84%E5%A5%A5%E7%A7%98%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%88%B0%E6%99%BA%E8%83%BD/>第3章 预训练的奥秘：从数据到智能</a></li></ul></li><li><input type=checkbox id=section-da88ac5e3d01ea6f4b2996cb87ecf19f class=toggle>
<label for=section-da88ac5e3d01ea6f4b2996cb87ecf19f class=flex><a role=button>第三部分：数据工程与定制化</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%9A%E5%88%B6%E5%8C%96/%E7%AC%AC1%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/>第1章 数据工程基础</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%9A%E5%88%B6%E5%8C%96/%E7%AC%AC2%E7%AB%A0_%E5%BE%AE%E8%B0%83%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9E%E6%A8%A1%E5%9E%8B/>第2章 微调你的专属模型</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%9A%E5%88%B6%E5%8C%96/%E7%AC%AC3%E7%AB%A0_%E4%B8%8E%E4%BA%BA%E7%B1%BB%E5%AF%B9%E9%BD%90%E5%81%8F%E5%A5%BD%E4%BC%98%E5%8C%96/>第3章 与人类对齐：偏好优化</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%9A%E5%88%B6%E5%8C%96/%E7%AC%AC4%E7%AB%A0_%E5%88%9B%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84%E5%B5%8C%E5%85%A5%E6%A8%A1%E5%9E%8B/>第4章 创建更优的嵌入模型</a></li></ul></li><li><input type=checkbox id=section-81f0a7a10bc544ea0e1fd883e2a436eb class=toggle>
<label for=section-81f0a7a10bc544ea0e1fd883e2a436eb class=flex><a role=button>第四部分：大模型应用开发</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E7%AC%AC1%E7%AB%A0_%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AD%A6%E4%B9%A0/>第1章 提示工程与上下文学习</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E7%AC%AC2%E7%AB%A0_%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90rag%E5%8E%9F%E7%90%86/>第2章 检索增强生成（RAG）原理</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E7%AC%AC3%E7%AB%A0_%E6%99%BA%E8%83%BD%E4%BD%93agent%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/>第3章 智能体（Agent）核心机制</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E7%AC%AC4%E7%AB%A0_%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86/>第4章 多模态大模型原理</a></li></ul></li><li><input type=checkbox id=section-0509decfe880d3d2074947902aea8022 class=toggle>
<label for=section-0509decfe880d3d2074947902aea8022 class=flex><a role=button>第五部分：工程实战工具栈</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%B7%A5%E5%85%B7%E6%A0%88/%E7%AC%AC1%E7%AB%A0_hugging_face%E7%94%9F%E6%80%81%E5%85%A8%E6%99%AF/>第1章 Hugging Face生态全景</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%B7%A5%E5%85%B7%E6%A0%88/%E7%AC%AC2%E7%AB%A0_llama-factory%E5%BE%AE%E8%B0%83%E5%B7%A5%E5%8E%82/>第2章 LLaMA-Factory微调工厂</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%B7%A5%E5%85%B7%E6%A0%88/%E7%AC%AC3%E7%AB%A0_trl%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/>第3章 TRL与强化学习实战</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%B7%A5%E5%85%B7%E6%A0%88/%E7%AC%AC4%E7%AB%A0_deepspeed%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/>第4章 DeepSpeed分布式训练</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%B7%A5%E5%85%B7%E6%A0%88/%E7%AC%AC5%E7%AB%A0_%E7%AB%AF%E5%88%B0%E7%AB%AFllm%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/>第5章 端到端LLM项目实战</a></li></ul></li><li><input type=checkbox id=section-dc465ed94a0f7fb78440cab8a8a2a28b class=toggle>
<label for=section-dc465ed94a0f7fb78440cab8a8a2a28b class=flex><a role=button>第六部分：生产部署与评估</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%AF%84%E4%BC%B0/%E7%AC%AC1%E7%AB%A0_%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%8E%A8%E7%90%86%E5%8A%A0%E9%80%9F/>第1章 模型压缩与推理加速</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%AF%84%E4%BC%B0/%E7%AC%AC2%E7%AB%A0_vllm%E9%AB%98%E6%80%A7%E8%83%BD%E6%8E%A8%E7%90%86/>第2章 vLLM高性能推理</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%AF%84%E4%BC%B0/%E7%AC%AC3%E7%AB%A0_%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%BD%93%E7%B3%BB/>第3章 模型评估体系</a></li></ul></li><li><input type=checkbox id=section-54ec04ac2cdda7238de2ed38f0bcb7b1 class=toggle checked>
<label for=section-54ec04ac2cdda7238de2ed38f0bcb7b1 class=flex><a role=button>第七部分：高级技术专题</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0_%E9%95%BF%E4%B8%8A%E4%B8%8B%E6%96%87%E6%8A%80%E6%9C%AF/>第1章 长上下文技术</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC2%E7%AB%A0_%E6%96%B0%E5%9E%8B%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/>第2章 新型架构探索</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC3%E7%AB%A0_%E6%8E%A8%E7%90%86%E5%8A%A0%E9%80%9F%E9%BB%91%E7%A7%91%E6%8A%80/>第3章 推理加速黑科技</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC4%E7%AB%A0_%E6%8E%A8%E7%90%86%E6%A8%A1%E5%9E%8B%E4%B8%93%E9%A2%98/ class=active>第4章 推理模型专题</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC5%E7%AB%A0_%E6%A8%A1%E5%9E%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%8F%AF%E8%A7%A3%E9%87%8A%E6%80%A7/>第5章 模型安全与可解释性</a></li></ul></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/glossary/>GLOSSARY</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/roadmap/>ROADMAP</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/summary/>SUMMARY</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E5%AE%8C%E7%BB%93%E6%8A%A5%E5%91%8A/>完结报告</a></li></ul></li><li><input type=checkbox id=section-7177254393287994b491879262a62a06 class=toggle>
<label for=section-7177254393287994b491879262a62a06 class=flex><a role=button>实践笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/2.-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-fastapi/>深入理解 FastAPI</a></li><li><a href=/notebooks/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/4.-agent%E6%9C%80%E4%BD%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>Agent最佳设计模式</a></li></ul></li><li><input type=checkbox id=section-0172eb8516eeb7b4e657f3949a135c25 class=toggle>
<label for=section-0172eb8516eeb7b4e657f3949a135c25 class=flex><a role=button>机器学习笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC01%E7%AB%A0_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/>第01章 机器学习概览</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC02%E7%AB%A0_%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%E4%B8%8E%E5%BE%AE%E7%A7%AF%E5%88%86/>第02章 矩阵运算与微积分</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC03%E7%AB%A0_svd%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/>第03章 SVD与矩阵分解</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC04%E7%AB%A0_%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83_%E6%8C%87%E6%95%B0%E6%97%8F%E4%B8%8E%E5%85%B1%E8%BD%AD%E5%85%88%E9%AA%8C/>第04章 概率分布 指数族与共轭先验</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC05%E7%AB%A0_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/>第05章 线性回归</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC06%E7%AB%A0_%E6%84%9F%E7%9F%A5%E6%9C%BA/>第06章 感知机</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC07%E7%AB%A0_%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BAsvm/>第07章 支持向量机(SVM)</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC08%E7%AB%A0_%E6%A0%B8%E6%96%B9%E6%B3%95/>第08章 核方法</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC09%E7%AB%A0_%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/>第09章 决策树与集成学习</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/>第10章 逻辑回归与最大熵模型</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E7%AB%A0_%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8Bglm/>第11章 广义线性模型(GLM)</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E7%AB%A0_%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B_%E8%A1%A8%E7%A4%BA/>第13章 概率图模型 表示</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E7%AB%A0_%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B_%E6%8E%A8%E6%96%AD/>第14章 概率图模型 推断</a></li><li><input type=checkbox id=section-b17efd79c46843a887113a063f929150 class=toggle>
<label for=section-b17efd79c46843a887113a063f929150 class=flex><a role=button>assets</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/skills/>skills</a></li></ul></li><li><input type=checkbox id=section-29762f225235d2ac19b613cc28b093c8 class=toggle>
<label for=section-29762f225235d2ac19b613cc28b093c8 class=flex><a href=/notebooks/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>深度学习笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC1%E7%AB%A0_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/>第1章 深度学习基础</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/icons/menu.svg class=book-icon alt=Menu></label><h3>第4章 推理模型专题</h3><label for=toc-control><img src=/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#目录>目录</a></li><li><a href=#一推理模型的理论基础>一、推理模型的理论基础</a><ul><li><a href=#1-什么是推理模型>1. 什么是推理模型?</a><ul><li><a href=#快速推理-vs-深度推理>快速推理 vs 深度推理</a></li></ul></li><li><a href=#2-chain-of-thought-cot-的数学原理>2. Chain-of-Thought (CoT) 的数学原理</a><ul><li><a href=#21-传统生成-vs-cot生成>2.1 传统生成 vs CoT生成</a></li><li><a href=#22-为什么cot有效-概率视角>2.2 为什么CoT有效? 概率视角</a></li><li><a href=#23-self-consistency-cot的增强版>2.3 Self-Consistency: CoT的增强版</a></li></ul></li></ul></li><li><a href=#二推理时计算增强-test-time-compute>二、推理时计算增强 (Test-Time Compute)</a><ul><li><a href=#1-推理时计算新的-scaling-law>1. 推理时计算：新的 Scaling Law</a><ul><li><a href=#从训练时到推理时的范式转变>从训练时到推理时的范式转变</a></li><li><a href=#2-数学基础搜索算法>2. 数学基础：搜索算法</a></li></ul></li></ul></li><li><a href=#三高级推理算法实战>三、高级推理算法实战</a><ul><li><a href=#1-tree-of-thoughts-tot>1. Tree-of-Thoughts (ToT)</a></li><li><a href=#2-best-of-n-rejection-sampling>2. Best-of-N (Rejection Sampling)</a></li><li><a href=#3-mcts-蒙特卡洛树搜索>3. MCTS (蒙特卡洛树搜索)</a><ul><li><a href=#mcts-四步循环>MCTS 四步循环</a></li><li><a href=#ucb-upper-confidence-bound-公式>UCB (Upper Confidence Bound) 公式</a></li></ul></li></ul></li><li><a href=#四openai-o1闭源先锋>四、OpenAI O1：闭源先锋</a><ul><li><a href=#1-核心架构推测>1. 核心架构推测</a></li><li><a href=#2-prm-vs-orm-两种奖励模型对比>2. PRM vs ORM: 两种奖励模型对比</a><ul><li><a href=#prm-的训练流程>PRM 的训练流程</a></li></ul></li><li><a href=#3-o1-的效果与代价>3. O1 的效果与代价</a></li></ul></li><li><a href=#五deepseek-r1开源界的盗火者>五、DeepSeek-R1：开源界的"盗火者"</a><ul><li><a href=#1-r1-zero从零开始的奇迹>1. R1-Zero：从零开始的奇迹</a></li><li><a href=#2-核心算法grpo-group-relative-policy-optimization>2. 核心算法：GRPO (Group Relative Policy Optimization)</a><ul><li><a href=#grpo-完整数学推导>GRPO 完整数学推导</a></li><li><a href=#pytorch-完整实现>PyTorch 完整实现</a></li><li><a href=#grpo-vs-ppo-对比>GRPO vs PPO 对比</a></li></ul></li><li><a href=#3-蒸馏-distillationr1-给小模型的礼物>3. &ldquo;蒸馏&rdquo; (Distillation)：R1 给小模型的礼物</a></li></ul></li><li><a href=#六复现-r1-的完整路线图>六、复现 R1 的完整路线图</a><ul><li><a href=#阶段1-冷启动-cold-start---deepseek-r1-的关键发现>阶段1: 冷启动 (Cold Start) - DeepSeek-R1 的关键发现</a><ul><li><a href=#为什么-cold-start-数据至关重要>为什么 Cold Start 数据至关重要？</a></li><li><a href=#cold-start-数据的质量标准>Cold Start 数据的质量标准</a></li></ul></li><li><a href=#阶段2-推理增强-rl>阶段2: 推理增强 (RL)</a></li><li><a href=#阶段3-拒绝采样-rejection-sampling>阶段3: 拒绝采样 (Rejection Sampling)</a></li></ul></li><li><a href=#七实战案例构建数学推理系统>七、实战案例：构建数学推理系统</a><ul><li><a href=#完整代码示例>完整代码示例</a></li></ul></li><li><a href=#八关键技术对比总结>八、关键技术对比总结</a><ul><li><a href=#推理技术演进路线>推理技术演进路线</a></li><li><a href=#各技术适用场景>各技术适用场景</a></li></ul></li><li><a href=#九未来展望与研究方向>九、未来展望与研究方向</a><ul><li><a href=#1-开放问题>1. 开放问题</a></li><li><a href=#2-前沿研究方向>2. 前沿研究方向</a></li><li><a href=#3-工程实践建议>3. 工程实践建议</a></li></ul></li><li><a href=#十参考资源>十、参考资源</a><ul><li><a href=#论文>论文</a></li><li><a href=#开源项目>开源项目</a></li><li><a href=#实用工具>实用工具</a></li></ul></li><li><a href=#本章总结>本章总结</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=第4章推理模型专题-reasoning-models-o1--deepseek-r1>第4章：推理模型专题 (Reasoning Models: O1 & DeepSeek-R1)<a class=anchor href=#%e7%ac%ac4%e7%ab%a0%e6%8e%a8%e7%90%86%e6%a8%a1%e5%9e%8b%e4%b8%93%e9%a2%98-reasoning-models-o1--deepseek-r1>#</a></h1><blockquote class=book-hint><p>当前最前沿的赛道。从 OpenAI 的闭源 o1 到 DeepSeek 的开源 R1，大模型终于学会了"慢思考"。本章深入探讨推理模型的理论基础、核心技术与实战应用。</p></blockquote><hr><h2 id=目录>目录<a class=anchor href=#%e7%9b%ae%e5%bd%95>#</a></h2><ul><li><a href=#%e4%b8%80%e6%8e%a8%e7%90%86%e6%a8%a1%e5%9e%8b%e7%9a%84%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%80>一、推理模型的理论基础</a></li><li><a href=#%e4%ba%8copenai-o1-%e7%9a%84%e6%8a%80%e6%9c%af%e7%8c%9c%e6%83%b3>二、OpenAI o1 的技术猜想</a></li><li><a href=#%e4%b8%89deepseek-r1-%e7%9a%84%e6%8a%80%e6%9c%af%e8%a7%a3%e5%af%86>三、DeepSeek-R1 的技术解密</a></li><li><a href=#%e5%9b%9b%e6%8e%a8%e7%90%86%e6%97%b6%e8%ae%a1%e7%ae%97%e5%a2%9e%e5%bc%ba%e5%ae%9e%e6%88%98>四、推理时计算增强实战</a></li><li><a href=#%e4%ba%94%e9%aa%8c%e8%af%81%e5%99%a8-verifier-%e8%ae%ad%e7%bb%83>五、验证器 (Verifier) 训练</a></li><li><a href=#%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93>本章小结</a></li></ul><hr><h2 id=一推理模型的理论基础>一、推理模型的理论基础<a class=anchor href=#%e4%b8%80%e6%8e%a8%e7%90%86%e6%a8%a1%e5%9e%8b%e7%9a%84%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%80>#</a></h2><h3 id=1-什么是推理模型>1. 什么是推理模型?<a class=anchor href=#1-%e4%bb%80%e4%b9%88%e6%98%af%e6%8e%a8%e7%90%86%e6%a8%a1%e5%9e%8b>#</a></h3><p>推理模型(Reasoning Model)是指能够进行<strong>多步骤逻辑推理</strong>的大语言模型。与传统的"快速响应"模式不同,推理模型会：</p><ol><li><strong>展开思维链</strong> - 将复杂问题分解为多个子问题</li><li><strong>自我验证</strong> - 检查中间步骤的正确性</li><li><strong>回溯修正</strong> - 发现错误时重新推理</li></ol><p>这种能力在数学、代码、逻辑推理等任务上至关重要。</p><h4 id=快速推理-vs-深度推理>快速推理 vs 深度推理<a class=anchor href=#%e5%bf%ab%e9%80%9f%e6%8e%a8%e7%90%86-vs-%e6%b7%b1%e5%ba%a6%e6%8e%a8%e7%90%86>#</a></h4><table><thead><tr><th>特性</th><th>快速推理 (Fast Thinking)</th><th>深度推理 (Slow Thinking)</th></tr></thead><tbody><tr><td><strong>响应时间</strong></td><td>秒级</td><td>分钟级</td></tr><tr><td><strong>思考步骤</strong></td><td>1-3步</td><td>10-100+步</td></tr><tr><td><strong>适用场景</strong></td><td>闲聊、翻译、摘要</td><td>数学、编程、逻辑推理</td></tr><tr><td><strong>代表模型</strong></td><td>GPT-4、Claude-3</td><td>O1、R1</td></tr><tr><td><strong>成本</strong></td><td>低</td><td>高(10-50倍)</td></tr></tbody></table><pre class=mermaid>graph LR
    A[用户问题] --&gt; B{是否需要深度推理?}
    B --&gt;|否| C[快速推理模型&lt;br/&gt;直接生成答案]
    B --&gt;|是| D[推理模型&lt;br/&gt;展开思维链]
    D --&gt; E[步骤1: 理解问题]
    E --&gt; F[步骤2: 制定方案]
    F --&gt; G[步骤3: 执行计算]
    G --&gt; H[步骤4: 验证答案]
    H --&gt; I{正确?}
    I --&gt;|否| F
    I --&gt;|是| J[输出最终答案]</pre><script src=/mermaid.min.js></script><script>mermaid.initialize({flowchart:{useMaxWidth:!0},theme:"default"})</script><h3 id=2-chain-of-thought-cot-的数学原理>2. Chain-of-Thought (CoT) 的数学原理<a class=anchor href=#2-chain-of-thought-cot-%e7%9a%84%e6%95%b0%e5%ad%a6%e5%8e%9f%e7%90%86>#</a></h3><p>CoT 的核心思想是:<strong>让模型输出中间推理步骤,而不是直接给出答案</strong>。</p><h4 id=21-传统生成-vs-cot生成>2.1 传统生成 vs CoT生成<a class=anchor href=#21-%e4%bc%a0%e7%bb%9f%e7%94%9f%e6%88%90-vs-cot%e7%94%9f%e6%88%90>#</a></h4><p><strong>传统方式(Direct Answer)</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Q: Roger有5个网球。他又买了2罐网球,每罐3个球。他现在有多少个网球?
</span></span><span class=line><span class=cl>A: 11个</span></span></code></pre></div><p><strong>CoT方式</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Q: Roger有5个网球。他又买了2罐网球,每罐3个球。他现在有多少个网球?
</span></span><span class=line><span class=cl>A: 让我一步步思考:
</span></span><span class=line><span class=cl>1. Roger最初有5个球
</span></span><span class=line><span class=cl>2. 他买了2罐,每罐3个,所以是 2×3=6个球
</span></span><span class=line><span class=cl>3. 总共: 5+6=11个球
</span></span><span class=line><span class=cl>答案: 11个</span></span></code></pre></div><h4 id=22-为什么cot有效-概率视角>2.2 为什么CoT有效? 概率视角<a class=anchor href=#22-%e4%b8%ba%e4%bb%80%e4%b9%88cot%e6%9c%89%e6%95%88-%e6%a6%82%e7%8e%87%e8%a7%86%e8%a7%92>#</a></h4><p>设问题为 $q$,答案为 $a$,中间步骤为 $z$。</p><p><strong>传统模型</strong>: 直接建模 $P(a|q)$</p><p><strong>CoT模型</strong>: 建模 $P(a, z|q) = P(z|q) \cdot P(a|z, q)$</p><p>通过边际化:
$$
P(a|q) = \sum_z P(z|q) \cdot P(a|z, q)
$$</p><p><strong>关键洞察</strong>: 即使单个路径 $P(z|q)$ 不准确,通过采样多条路径并投票(Self-Consistency),可以提高最终答案的准确率!</p><h4 id=23-self-consistency-cot的增强版>2.3 Self-Consistency: CoT的增强版<a class=anchor href=#23-self-consistency-cot%e7%9a%84%e5%a2%9e%e5%bc%ba%e7%89%88>#</a></h4><p>算法流程:</p><ol><li>对同一问题,采样 $N$ 条不同的推理链 ${z_1, z_2, &mldr;, z_N}$</li><li>提取每条链的最终答案 ${a_1, a_2, &mldr;, a_N}$</li><li>通过多数投票选出最终答案: $a^* = \arg\max_a \sum_{i=1}^N \mathbb{1}[a_i = a]$</li></ol><pre class=mermaid>graph TD
    Q[问题: 2的8次方是多少?] --&gt; S1[采样路径1:&lt;br/&gt;2×2=4, 4×2=8,&lt;br/&gt;8×2=16, ..., 答案:256]
    Q --&gt; S2[采样路径2:&lt;br/&gt;2^4=16, 16×16=256,&lt;br/&gt;答案:256]
    Q --&gt; S3[采样路径3:&lt;br/&gt;2×2×2×2×2×2×2×2=256,&lt;br/&gt;答案:256]
    S1 --&gt; V[投票]
    S2 --&gt; V
    S3 --&gt; V
    V --&gt; A[最终答案: 256&lt;br/&gt;置信度:3/3]</pre><hr><h2 id=二推理时计算增强-test-time-compute>二、推理时计算增强 (Test-Time Compute)<a class=anchor href=#%e4%ba%8c%e6%8e%a8%e7%90%86%e6%97%b6%e8%ae%a1%e7%ae%97%e5%a2%9e%e5%bc%ba-test-time-compute>#</a></h2><h3 id=1-推理时计算新的-scaling-law>1. 推理时计算：新的 Scaling Law<a class=anchor href=#1-%e6%8e%a8%e7%90%86%e6%97%b6%e8%ae%a1%e7%ae%97%e6%96%b0%e7%9a%84-scaling-law>#</a></h3><h4 id=从训练时到推理时的范式转变>从训练时到推理时的范式转变<a class=anchor href=#%e4%bb%8e%e8%ae%ad%e7%bb%83%e6%97%b6%e5%88%b0%e6%8e%a8%e7%90%86%e6%97%b6%e7%9a%84%e8%8c%83%e5%bc%8f%e8%bd%ac%e5%8f%98>#</a></h4><p><strong>传统范式</strong>：性能 ∝ 训练时计算（模型参数、数据量、训练FLOPs）。</p><p><strong>新范式</strong>：性能 = f(模型参数, 训练数据, <strong>推理时计算</strong>)。</p><p><strong>核心洞察</strong>：</p><ul><li>在推理时"多思考几步"，性价比远高于暴力增大模型。</li><li><strong>小模型 + 长思考 ≈ 大模型 + 短思考</strong>。</li></ul><h4 id=2-数学基础搜索算法>2. 数学基础：搜索算法<a class=anchor href=#2-%e6%95%b0%e5%ad%a6%e5%9f%ba%e7%a1%80%e6%90%9c%e7%b4%a2%e7%ae%97%e6%b3%95>#</a></h4><p>推理过程可以建模为<strong>状态空间搜索</strong>：</p><ul><li><strong>状态 $s_t$</strong>：当前推理链。</li><li><strong>动作 $a_t$</strong>：生成下一步。</li><li><strong>目标</strong>：找到通往正确答案的路径。</li></ul><table><thead><tr><th style=text-align:left>算法</th><th style=text-align:left>策略</th><th style=text-align:left>计算开销</th><th style=text-align:left>适用场景</th></tr></thead><tbody><tr><td style=text-align:left><strong>Greedy</strong></td><td style=text-align:left>每步选最佳</td><td style=text-align:left>1x</td><td style=text-align:left>简单问题</td></tr><tr><td style=text-align:left><strong>Beam Search</strong></td><td style=text-align:left>保留 Top-K 路径</td><td style=text-align:left>Kx</td><td style=text-align:left>中等复杂度</td></tr><tr><td style=text-align:left><strong>Best-of-N</strong></td><td style=text-align:left>采样 N 次取最佳</td><td style=text-align:left>Nx</td><td style=text-align:left>不确定性高</td></tr><tr><td style=text-align:left><strong>MCTS</strong></td><td style=text-align:left>蒙特卡洛树搜索</td><td style=text-align:left>10-100x</td><td style=text-align:left>复杂推理 (AlphaGo 范式)</td></tr></tbody></table><hr><h2 id=三高级推理算法实战>三、高级推理算法实战<a class=anchor href=#%e4%b8%89%e9%ab%98%e7%ba%a7%e6%8e%a8%e7%90%86%e7%ae%97%e6%b3%95%e5%ae%9e%e6%88%98>#</a></h2><h3 id=1-tree-of-thoughts-tot>1. Tree-of-Thoughts (ToT)<a class=anchor href=#1-tree-of-thoughts-tot>#</a></h3><p><strong>原理</strong>：让模型在思维树上进行 DFS/BFS 搜索，允许回溯（Backtracking）。</p><p><strong>代码实现 (24点游戏求解器)</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>ToTSolver</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Tree-of-Thoughts 求解器&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>model</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>model</span> <span class=o>=</span> <span class=n>model</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>generate_thoughts</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>state</span><span class=p>,</span> <span class=n>k</span><span class=o>=</span><span class=mi>3</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;生成 k 个后续步骤&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>prompt</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;当前状态：</span><span class=si>{</span><span class=n>state</span><span class=si>}</span><span class=se>\n</span><span class=s2>请给出</span><span class=si>{</span><span class=n>k</span><span class=si>}</span><span class=s2>个可能的下一步：&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>generate</span><span class=p>(</span><span class=n>prompt</span><span class=p>,</span> <span class=n>n</span><span class=o>=</span><span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>evaluate_state</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;评估状态价值 (0-1)&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>prompt</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;评估以下状态解决问题的可能性(0-10分)：</span><span class=si>{</span><span class=n>state</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>score</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>generate</span><span class=p>(</span><span class=n>prompt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>float</span><span class=p>(</span><span class=n>score</span><span class=p>)</span> <span class=o>/</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>bfs_solve</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>initial_state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>frontier</span> <span class=o>=</span> <span class=p>[(</span><span class=n>initial_state</span><span class=p>,</span> <span class=mi>0</span><span class=p>)]</span> <span class=c1># (状态, 分数)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>frontier</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 1. 扩展 (Expansion)</span>
</span></span><span class=line><span class=cl>            <span class=n>current_state</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>frontier</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>thoughts</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>generate_thoughts</span><span class=p>(</span><span class=n>current_state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 2. 评估 (Evaluation)</span>
</span></span><span class=line><span class=cl>            <span class=n>candidates</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>thought</span> <span class=ow>in</span> <span class=n>thoughts</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>score</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>evaluate_state</span><span class=p>(</span><span class=n>thought</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>score</span> <span class=o>&gt;</span> <span class=mf>0.8</span><span class=p>:</span> <span class=c1># 剪枝</span>
</span></span><span class=line><span class=cl>                    <span class=n>candidates</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>thought</span><span class=p>,</span> <span class=n>score</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>frontier</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>candidates</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 3. 检查结束条件</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>cand</span><span class=p>,</span> <span class=n>score</span> <span class=ow>in</span> <span class=n>candidates</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_solved</span><span class=p>(</span><span class=n>cand</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=n>cand</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;无解&#34;</span></span></span></code></pre></div><h3 id=2-best-of-n-rejection-sampling>2. Best-of-N (Rejection Sampling)<a class=anchor href=#2-best-of-n-rejection-sampling>#</a></h3><p><strong>原理</strong>：单纯地"大力出奇迹"。生成 N 个答案，然后用<strong>验证器 (Verifier)</strong> 挑最好的。</p><ul><li><strong>N=1</strong>: 18.1% (MATH数据集)</li><li><strong>N=10</strong>: 31.5%</li><li><strong>N=100</strong>: 42.3%</li></ul><p><strong>关键</strong>：你需要一个好的验证器（Reward Model 或 代码执行器）。</p><h3 id=3-mcts-蒙特卡洛树搜索>3. MCTS (蒙特卡洛树搜索)<a class=anchor href=#3-mcts-%e8%92%99%e7%89%b9%e5%8d%a1%e6%b4%9b%e6%a0%91%e6%90%9c%e7%b4%a2>#</a></h3><p>这是 AlphaGo 的核心，也是未来推理引擎的终极形态。</p><h4 id=mcts-四步循环>MCTS 四步循环<a class=anchor href=#mcts-%e5%9b%9b%e6%ad%a5%e5%be%aa%e7%8e%af>#</a></h4><ol><li><strong>Selection (选择)</strong>: 选择最有潜力的节点（利用 UCB 公式平衡探索与利用）。</li><li><strong>Expansion (扩展)</strong>: 生成下一个 Token 或 步骤。</li><li><strong>Simulation (模拟)</strong>: 快速模拟（Rollout）到底，看最终结果。</li><li><strong>Backpropagation (反向传播)</strong>: 将结果价值反向传播，更新路径权重。</li></ol><pre class=mermaid>graph TD
    A[根节点: 初始问题] --&gt; B[Selection&lt;br/&gt;用UCB选择最优子节点]
    B --&gt; C[Expansion&lt;br/&gt;生成新的推理步骤]
    C --&gt; D[Simulation&lt;br/&gt;快速Rollout到终点]
    D --&gt; E[Evaluation&lt;br/&gt;评估最终答案质量]
    E --&gt; F[Backpropagation&lt;br/&gt;更新路径价值]
    F --&gt; B</pre><h4 id=ucb-upper-confidence-bound-公式>UCB (Upper Confidence Bound) 公式<a class=anchor href=#ucb-upper-confidence-bound-%e5%85%ac%e5%bc%8f>#</a></h4><p>MCTS 的核心是平衡<strong>探索 (Exploration)</strong> 与<strong>利用 (Exploitation)</strong>:</p><p>$$
\text{UCB}(s, a) = Q(s, a) + c \sqrt{\frac{\ln N(s)}{N(s, a)}}
$$</p><p>其中:</p><ul><li>$Q(s, a)$: 动作 $a$ 的平均奖励 (利用项)</li><li>$N(s)$: 父节点访问次数</li><li>$N(s, a)$: 该动作被选择的次数</li><li>$c$: 探索常数 (通常取 $\sqrt{2}$)</li></ul><hr><h2 id=四openai-o1闭源先锋>四、OpenAI O1：闭源先锋<a class=anchor href=#%e5%9b%9bopenai-o1%e9%97%ad%e6%ba%90%e5%85%88%e9%94%8b>#</a></h2><h3 id=1-核心架构推测>1. 核心架构推测<a class=anchor href=#1-%e6%a0%b8%e5%bf%83%e6%9e%b6%e6%9e%84%e6%8e%a8%e6%b5%8b>#</a></h3><p>OpenAI 从未公开 o1 的细节，但社区反推其核心机制为：<strong>隐式思维链 (Hidden CoT)</strong>。</p><ul><li><strong>训练目标</strong>：不仅要 Answer 正确，还要 Reasoning Chain 正确。</li><li><strong>RLHF 变体</strong>：使用 <strong>Process Reward Model (PRM)</strong> 对思维链的每一步进行打分。</li></ul><h3 id=2-prm-vs-orm-两种奖励模型对比>2. PRM vs ORM: 两种奖励模型对比<a class=anchor href=#2-prm-vs-orm-%e4%b8%a4%e7%a7%8d%e5%a5%96%e5%8a%b1%e6%a8%a1%e5%9e%8b%e5%af%b9%e6%af%94>#</a></h3><table><thead><tr><th>特性</th><th><strong>ORM (Outcome Reward Model)</strong></th><th><strong>PRM (Process Reward Model)</strong></th></tr></thead><tbody><tr><td><strong>评估对象</strong></td><td>只看最终答案</td><td>评估每个推理步骤</td></tr><tr><td><strong>训练信号</strong></td><td>稀疏 (只在最后给奖励)</td><td>密集 (每步都有反馈)</td></tr><tr><td><strong>优点</strong></td><td>训练简单,标注成本低</td><td>能捕捉推理错误,泛化性更好</td></tr><tr><td><strong>缺点</strong></td><td>无法识别"歪打正着"</td><td>标注成本高 (需要逐步标注)</td></tr><tr><td><strong>适用场景</strong></td><td>简单任务 (翻译、摘要)</td><td>复杂推理 (数学、代码)</td></tr></tbody></table><h4 id=prm-的训练流程>PRM 的训练流程<a class=anchor href=#prm-%e7%9a%84%e8%ae%ad%e7%bb%83%e6%b5%81%e7%a8%8b>#</a></h4><pre class=mermaid>graph LR
    A[问题] --&gt; B[生成推理链]
    B --&gt; C[人类标注员&lt;br/&gt;逐步打分]
    C --&gt; D[训练PRM模型]
    D --&gt; E[用PRM指导RL训练]
    E --&gt; F[更强的推理模型]</pre><p><strong>关键数据集</strong>: OpenAI 在论文 <em>Let&rsquo;s Verify Step by Step</em> 中公开了 PRM800K 数据集,包含 800K 个逐步标注的数学推理链。</p><h3 id=3-o1-的效果与代价>3. O1 的效果与代价<a class=anchor href=#3-o1-%e7%9a%84%e6%95%88%e6%9e%9c%e4%b8%8e%e4%bb%a3%e4%bb%b7>#</a></h3><ul><li><strong>数学能力</strong>：在 AIME (高中数学奥赛) 上，GPT-4o 正确率 13%，o1 飙升至 83%。</li><li><strong>代价</strong>：推理速度慢 10-50 倍，Token 成本高昂。</li></ul><hr><h2 id=五deepseek-r1开源界的盗火者>五、DeepSeek-R1：开源界的"盗火者"<a class=anchor href=#%e4%ba%94deepseek-r1%e5%bc%80%e6%ba%90%e7%95%8c%e7%9a%84%e7%9b%97%e7%81%ab%e8%80%85>#</a></h2><p>DeepSeek-R1 的发布证明了：<strong>纯强化学习 (Pure RL) 可以自发涌现出推理能力</strong>。</p><h3 id=1-r1-zero从零开始的奇迹>1. R1-Zero：从零开始的奇迹<a class=anchor href=#1-r1-zero%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84%e5%a5%87%e8%bf%b9>#</a></h3><p>完全不使用人类标注的 SFT 数据，直接给模型一堆数学题，让它自己试错。</p><ul><li><strong>Aha Moment (顿悟时刻)</strong>：模型在数万次失败后，突然学会了"自我反思" (Self-Reflection) —— <em>&ldquo;等等，我刚才的思路好像不对，让我重新算一下&rdquo;</em>。</li><li>这种"自言自语"的能力不是人类教的，是为了拿到 RL 奖励而自发进化出来的。</li></ul><pre class=mermaid>graph TD
    A[Base Model&lt;br/&gt;无推理能力] --&gt; B[RL训练&lt;br/&gt;10000次失败]
    B --&gt; C[Aha Moment&lt;br/&gt;自发涌现自我反思]
    C --&gt; D[继续RL训练&lt;br/&gt;50000次]
    D --&gt; E[R1-Zero&lt;br/&gt;接近人类水平]</pre><h3 id=2-核心算法grpo-group-relative-policy-optimization>2. 核心算法：GRPO (Group Relative Policy Optimization)<a class=anchor href=#2-%e6%a0%b8%e5%bf%83%e7%ae%97%e6%b3%95grpo-group-relative-policy-optimization>#</a></h3><p>这是 DeepSeek-R1 最重要的技术贡献。GRPO 通过 <strong>Group Normalization</strong> 巧妙地省略了 Value Model，使 RL 训练成本降低 50%。</p><h4 id=grpo-完整数学推导>GRPO 完整数学推导<a class=anchor href=#grpo-%e5%ae%8c%e6%95%b4%e6%95%b0%e5%ad%a6%e6%8e%a8%e5%af%bc>#</a></h4><p><strong>传统 PPO 的问题</strong>：
需要两个模型：</p><ol><li><strong>Policy Model</strong> $\pi_\theta$: 生成输出</li><li><strong>Value Model</strong> $V_\phi$: 估计状态价值作为 Baseline</li></ol><p>这导致：</p><ul><li>显存翻倍（2个70B模型 = 280GB显存）</li><li>训练不稳定（Policy 和 Value 互相影响）</li></ul><p><strong>GRPO 的核心创新</strong>：
对每个问题 $q$，采样一组输出 ${o_1, &mldr;, o_G}$（通常 $G=4$ 或 $G=8$），用<strong>组内平均奖励</strong>代替 Value Model。</p><p><strong>数学公式</strong>：</p><ol><li><p><strong>奖励归一化</strong>：
$$
\hat{r}_i = \frac{r_i - \mu_G}{\sigma_G + \epsilon}
$$
其中：</p><ul><li>$\mu_G = \frac{1}{G}\sum_{i=1}^G r_i$ (组内均值，替代Value Model)</li><li>$\sigma_G = \sqrt{\frac{1}{G}\sum_{i=1}^G (r_i - \mu_G)^2}$ (组内标准差)</li><li>$\epsilon = 10^{-8}$ (数值稳定项)</li></ul></li><li><p><strong>策略梯度更新</strong>：
$$
\mathcal{L}<em>{\text{GRPO}} = -\mathbb{E}</em>{q, {o_i}<em>{i=1}^G} \left[ \sum</em>{i=1}^G \hat{r}<em>i \cdot \log \pi</em>\theta(o_i | q) \right]
$$</p></li><li><p><strong>为什么 Group Normalization 有效？</strong></p><ul><li><strong>假设</strong>：同一问题的多个采样，它们的期望价值应该相近（都是从同一个 Policy 采样的）。</li><li><strong>结论</strong>：组平均值 $\mu_G$ 是该状态真实价值 $V(q)$ 的无偏估计。</li><li><strong>降噪</strong>：通过归一化，将奖励信号标准化，避免不同问题的奖励尺度差异。</li></ul></li></ol><h4 id=pytorch-完整实现>PyTorch 完整实现<a class=anchor href=#pytorch-%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>torch</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>torch.nn.functional</span> <span class=k>as</span> <span class=nn>F</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>grpo_loss</span><span class=p>(</span><span class=n>policy_model</span><span class=p>,</span> <span class=n>questions</span><span class=p>,</span> <span class=n>group_size</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=n>temperature</span><span class=o>=</span><span class=mf>1.0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    GRPO 损失函数实现
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        policy_model: 策略模型 (LLM)
</span></span></span><span class=line><span class=cl><span class=s2>        questions: 问题列表 [batch_size]
</span></span></span><span class=line><span class=cl><span class=s2>        group_size: 每个问题采样的输出数量
</span></span></span><span class=line><span class=cl><span class=s2>        temperature: 采样温度
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>batch_size</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>questions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>all_outputs</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>all_log_probs</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>all_rewards</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 1. 对每个问题采样 G 个输出</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>q</span> <span class=ow>in</span> <span class=n>questions</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>outputs</span> <span class=o>=</span> <span class=n>policy_model</span><span class=o>.</span><span class=n>generate</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>q</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>n</span><span class=o>=</span><span class=n>group_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>temperature</span><span class=o>=</span><span class=n>temperature</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>return_log_probs</span><span class=o>=</span><span class=kc>True</span>  <span class=c1># 需要返回每个Token的log概率</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 2. 计算每个输出的奖励 (通过验证器)</span>
</span></span><span class=line><span class=cl>        <span class=n>rewards</span> <span class=o>=</span> <span class=p>[</span><span class=n>verify_answer</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>o</span><span class=o>.</span><span class=n>text</span><span class=p>)</span> <span class=k>for</span> <span class=n>o</span> <span class=ow>in</span> <span class=n>outputs</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>all_outputs</span><span class=o>.</span><span class=n>extend</span><span class=p>([</span><span class=n>o</span><span class=o>.</span><span class=n>text</span> <span class=k>for</span> <span class=n>o</span> <span class=ow>in</span> <span class=n>outputs</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>all_log_probs</span><span class=o>.</span><span class=n>extend</span><span class=p>([</span><span class=n>o</span><span class=o>.</span><span class=n>log_prob</span> <span class=k>for</span> <span class=n>o</span> <span class=ow>in</span> <span class=n>outputs</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>all_rewards</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>rewards</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 3. 转为 Tensor</span>
</span></span><span class=line><span class=cl>    <span class=n>log_probs</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>tensor</span><span class=p>(</span><span class=n>all_log_probs</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>torch</span><span class=o>.</span><span class=n>float32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>rewards</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>tensor</span><span class=p>(</span><span class=n>all_rewards</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>torch</span><span class=o>.</span><span class=n>float32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 4. 按组计算归一化优势 (Group Normalization)</span>
</span></span><span class=line><span class=cl>    <span class=n>advantages</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>batch_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>start_idx</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=n>group_size</span>
</span></span><span class=line><span class=cl>        <span class=n>end_idx</span> <span class=o>=</span> <span class=n>start_idx</span> <span class=o>+</span> <span class=n>group_size</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>group_rewards</span> <span class=o>=</span> <span class=n>rewards</span><span class=p>[</span><span class=n>start_idx</span><span class=p>:</span><span class=n>end_idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 组内归一化</span>
</span></span><span class=line><span class=cl>        <span class=n>mean_r</span> <span class=o>=</span> <span class=n>group_rewards</span><span class=o>.</span><span class=n>mean</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>std_r</span> <span class=o>=</span> <span class=n>group_rewards</span><span class=o>.</span><span class=n>std</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 避免除零</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>std_r</span> <span class=o>&lt;</span> <span class=mf>1e-8</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>group_advantages</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>zeros_like</span><span class=p>(</span><span class=n>group_rewards</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>group_advantages</span> <span class=o>=</span> <span class=p>(</span><span class=n>group_rewards</span> <span class=o>-</span> <span class=n>mean_r</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>std_r</span> <span class=o>+</span> <span class=mf>1e-8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>advantages</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>group_advantages</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>advantages</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>cat</span><span class=p>(</span><span class=n>advantages</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 5. Policy Gradient 损失</span>
</span></span><span class=line><span class=cl>    <span class=c1># 只强化那些比组平均好的输出 (Advantage &gt; 0)</span>
</span></span><span class=line><span class=cl>    <span class=n>loss</span> <span class=o>=</span> <span class=o>-</span><span class=p>(</span><span class=n>log_probs</span> <span class=o>*</span> <span class=n>advantages</span><span class=p>)</span><span class=o>.</span><span class=n>mean</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>loss</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>verify_answer</span><span class=p>(</span><span class=n>question</span><span class=p>,</span> <span class=n>output</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    验证器：检查答案是否正确
</span></span></span><span class=line><span class=cl><span class=s2>    返回: 1.0 (正确) 或 0.0 (错误)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 对于数学题，可以执行代码验证</span>
</span></span><span class=line><span class=cl>    <span class=c1># 对于代码题，可以运行测试用例</span>
</span></span><span class=line><span class=cl>    <span class=c1># 这里简化为规则匹配</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>predicted_ans</span> <span class=o>=</span> <span class=n>extract_answer</span><span class=p>(</span><span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>ground_truth</span> <span class=o>=</span> <span class=n>get_ground_truth</span><span class=p>(</span><span class=n>question</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mf>1.0</span> <span class=k>if</span> <span class=n>predicted_ans</span> <span class=o>==</span> <span class=n>ground_truth</span> <span class=k>else</span> <span class=mf>0.0</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mf>0.0</span></span></span></code></pre></div><h4 id=grpo-vs-ppo-对比>GRPO vs PPO 对比<a class=anchor href=#grpo-vs-ppo-%e5%af%b9%e6%af%94>#</a></h4><table><thead><tr><th>特性</th><th>PPO</th><th>GRPO</th></tr></thead><tbody><tr><td><strong>需要Critic</strong></td><td>是 (Value Model)</td><td>否</td></tr><tr><td><strong>显存占用</strong></td><td>2x模型参数</td><td>1x模型参数</td></tr><tr><td><strong>训练稳定性</strong></td><td>中等 (需要调整多个超参数)</td><td>高 (只有一个温度参数)</td></tr><tr><td><strong>收敛速度</strong></td><td>较慢</td><td>较快</td></tr><tr><td><strong>适用场景</strong></td><td>通用RL</td><td>有明确验证器的任务</td></tr></tbody></table><h3 id=3-蒸馏-distillationr1-给小模型的礼物>3. &ldquo;蒸馏&rdquo; (Distillation)：R1 给小模型的礼物<a class=anchor href=#3-%e8%92%b8%e9%a6%8f-distillationr1-%e7%bb%99%e5%b0%8f%e6%a8%a1%e5%9e%8b%e7%9a%84%e7%a4%bc%e7%89%a9>#</a></h3><p>DeepSeek 证明了：<strong>推理能力可以被蒸馏</strong>。</p><ul><li>用 R1 (671B) 生成数百万条高质量的思维链数据。</li><li>用这些数据去 SFT 一个小模型 (如 Qwen-7B)。</li><li>结果：小模型也能拥有强大的数学推理能力，且不需要昂贵的 RL 训练。</li></ul><pre class=mermaid>graph LR
    A[R1 671B&lt;br/&gt;强大推理能力] --&gt; B[生成1M+&lt;br/&gt;高质量思维链]
    B --&gt; C[SFT训练&lt;br/&gt;小模型7B]
    C --&gt; D[Distilled Model&lt;br/&gt;70%的R1能力]</pre><hr><h2 id=六复现-r1-的完整路线图>六、复现 R1 的完整路线图<a class=anchor href=#%e5%85%ad%e5%a4%8d%e7%8e%b0-r1-%e7%9a%84%e5%ae%8c%e6%95%b4%e8%b7%af%e7%ba%bf%e5%9b%be>#</a></h2><p>如果你想训练自己的推理模型：</p><h3 id=阶段1-冷启动-cold-start---deepseek-r1-的关键发现>阶段1: 冷启动 (Cold Start) - DeepSeek-R1 的关键发现<a class=anchor href=#%e9%98%b6%e6%ae%b51-%e5%86%b7%e5%90%af%e5%8a%a8-cold-start---deepseek-r1-%e7%9a%84%e5%85%b3%e9%94%ae%e5%8f%91%e7%8e%b0>#</a></h3><p><strong>目标</strong>: 让模型学会"说话方式"（思维链的格式规范）</p><h4 id=为什么-cold-start-数据至关重要>为什么 Cold Start 数据至关重要？<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88-cold-start-%e6%95%b0%e6%8d%ae%e8%87%b3%e5%85%b3%e9%87%8d%e8%a6%81>#</a></h4><p>DeepSeek-R1 论文明确指出：<strong>如果直接对 Base Model 进行 RL 训练，模型会学到错误的格式规范</strong>。</p><p><strong>问题场景</strong>：</p><ul><li>Base Model 不知道如何表达"让我思考一下"</li><li>RL 训练时，模型可能学会输出大量无意义的重复（如 &ldquo;&mldr;&rdquo; 重复1000次）来拖延时间</li><li>这种"格式崩溃"会导致后续 RL 训练完全失败</li></ul><p><strong>Cold Start 的作用</strong>：
通过少量（1K-10K条）高质量 SFT 数据，教会模型：</p><ol><li><strong>格式规范</strong>：如何用自然语言表达推理过程</li><li><strong>思维链结构</strong>：如何分步骤、有逻辑地推理</li><li><strong>元认知能力</strong>：学会说"等等，我刚才算错了"</li></ol><p><strong>DeepSeek-R1 的实践</strong>：</p><ul><li>使用 <strong>长思维链数据</strong>（从 R1-Zero 或 o1 生成）</li><li>数据量不需要多（5K-10K 足够）</li><li>关键是<strong>质量和格式规范性</strong></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 准备少量高质量SFT数据 (1K-10K条)</span>
</span></span><span class=line><span class=cl><span class=c1># 关键：必须包含完整的推理链，而不是简单的问答对</span>
</span></span><span class=line><span class=cl><span class=n>sft_data</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;question&#34;</span><span class=p>:</span> <span class=s2>&#34;计算 15 × 23&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;reasoning&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;&#34;让我仔细计算:
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>**思路**: 使用分配律简化计算
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>**步骤 1**: 将 23 分解为 20 + 3
</span></span></span><span class=line><span class=cl><span class=s2>  15 × 23 = 15 × (20 + 3)
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>**步骤 2**: 分别计算
</span></span></span><span class=line><span class=cl><span class=s2>  - 15 × 20 = 300
</span></span></span><span class=line><span class=cl><span class=s2>  - 15 × 3 = 45
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>**步骤 3**: 相加
</span></span></span><span class=line><span class=cl><span class=s2>  300 + 45 = 345
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>**验证**: 用竖式验证...
</span></span></span><span class=line><span class=cl><span class=s2>  (此处展示竖式过程)
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>**结论**: 答案是 345&#34;&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;answer&#34;</span><span class=p>:</span> <span class=s2>&#34;345&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;question&#34;</span><span class=p>:</span> <span class=s2>&#34;证明: 根号2 是无理数&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;reasoning&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;&#34;这是一个经典的反证法证明。
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>**假设**: 假设 √2 是有理数
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>**推导 1**: 则存在互质的整数 p, q，使得 √2 = p/q
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>**推导 2**: 两边平方...
</span></span></span><span class=line><span class=cl><span class=s2>  (此处展开详细推理过程，包含自我质疑)
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>等等，我需要检查一下这里的逻辑是否严谨...
</span></span></span><span class=line><span class=cl><span class=s2>  (展示自我修正过程)
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>**结论**: 矛盾！因此原假设错误，√2 是无理数。&#34;&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;answer&#34;</span><span class=p>:</span> <span class=s2>&#34;√2 是无理数（已证明）&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用标准SFT训练</span>
</span></span><span class=line><span class=cl><span class=c1># 注意：这一步不追求性能，只追求格式规范</span>
</span></span><span class=line><span class=cl><span class=n>model</span> <span class=o>=</span> <span class=n>train_sft</span><span class=p>(</span><span class=n>base_model</span><span class=p>,</span> <span class=n>sft_data</span><span class=p>,</span> <span class=n>epochs</span><span class=o>=</span><span class=mi>2</span><span class=o>-</span><span class=mi>3</span><span class=p>,</span> <span class=n>lr</span><span class=o>=</span><span class=mf>1e-5</span><span class=p>)</span></span></span></code></pre></div><h4 id=cold-start-数据的质量标准>Cold Start 数据的质量标准<a class=anchor href=#cold-start-%e6%95%b0%e6%8d%ae%e7%9a%84%e8%b4%a8%e9%87%8f%e6%a0%87%e5%87%86>#</a></h4><table><thead><tr><th>维度</th><th>要求</th><th>反例（应避免）</th></tr></thead><tbody><tr><td><strong>推理长度</strong></td><td>100-500 tokens</td><td>直接给答案（&lt;20 tokens）</td></tr><tr><td><strong>逻辑完整性</strong></td><td>每步都有因果关系</td><td>跳步推理、突然给出结论</td></tr><tr><td><strong>元认知</strong></td><td>包含"让我检查一下"等反思</td><td>从不自我修正</td></tr><tr><td><strong>格式规范</strong></td><td>使用标题、列表、公式</td><td>纯文本堆砌</td></tr><tr><td><strong>错误处理</strong></td><td>展示发现错误并修正的过程</td><td>从不犯错（不真实）</td></tr></tbody></table><p><strong>关键结论</strong>：Cold Start 是 RL 训练的"地基"。没有这一步，后续的 GRPO 训练会因为格式崩溃而失败。</p><h3 id=阶段2-推理增强-rl>阶段2: 推理增强 (RL)<a class=anchor href=#%e9%98%b6%e6%ae%b52-%e6%8e%a8%e7%90%86%e5%a2%9e%e5%bc%ba-rl>#</a></h3><p><strong>目标</strong>: 使用 GRPO 算法，在数学/代码数据集上进行大规模强化学习</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 准备数学题数据集 (MATH, GSM8K, etc.)</span>
</span></span><span class=line><span class=cl><span class=n>math_problems</span> <span class=o>=</span> <span class=n>load_dataset</span><span class=p>(</span><span class=s2>&#34;math_problems&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># GRPO训练循环</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>epoch</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>100</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>batch</span> <span class=ow>in</span> <span class=n>math_problems</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 1. 采样多个输出</span>
</span></span><span class=line><span class=cl>        <span class=n>outputs</span> <span class=o>=</span> <span class=n>model</span><span class=o>.</span><span class=n>generate</span><span class=p>(</span><span class=n>batch</span><span class=p>,</span> <span class=n>n</span><span class=o>=</span><span class=mi>8</span><span class=p>,</span> <span class=n>temperature</span><span class=o>=</span><span class=mf>0.8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 2. 用验证器评分</span>
</span></span><span class=line><span class=cl>        <span class=n>rewards</span> <span class=o>=</span> <span class=p>[</span><span class=n>verify_answer</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>o</span><span class=p>)</span> <span class=k>for</span> <span class=n>q</span><span class=p>,</span> <span class=n>o</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>batch</span><span class=p>,</span> <span class=n>outputs</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 3. 计算GRPO损失并更新</span>
</span></span><span class=line><span class=cl>        <span class=n>loss</span> <span class=o>=</span> <span class=n>grpo_loss</span><span class=p>(</span><span class=n>model</span><span class=p>,</span> <span class=n>outputs</span><span class=p>,</span> <span class=n>rewards</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>loss</span><span class=o>.</span><span class=n>backward</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>optimizer</span><span class=o>.</span><span class=n>step</span><span class=p>()</span></span></span></code></pre></div><h3 id=阶段3-拒绝采样-rejection-sampling>阶段3: 拒绝采样 (Rejection Sampling)<a class=anchor href=#%e9%98%b6%e6%ae%b53-%e6%8b%92%e7%bb%9d%e9%87%87%e6%a0%b7-rejection-sampling>#</a></h3><p><strong>目标</strong>: 在推理阶段，生成多个答案，保留经过验证器通过的那一个</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>inference_with_rejection_sampling</span><span class=p>(</span><span class=n>question</span><span class=p>,</span> <span class=n>n</span><span class=o>=</span><span class=mi>64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 生成 N 个候选答案</span>
</span></span><span class=line><span class=cl>    <span class=n>candidates</span> <span class=o>=</span> <span class=n>model</span><span class=o>.</span><span class=n>generate</span><span class=p>(</span><span class=n>question</span><span class=p>,</span> <span class=n>n</span><span class=o>=</span><span class=n>n</span><span class=p>,</span> <span class=n>temperature</span><span class=o>=</span><span class=mf>0.7</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 用验证器筛选</span>
</span></span><span class=line><span class=cl>    <span class=n>verified</span> <span class=o>=</span> <span class=p>[</span><span class=n>c</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>candidates</span> <span class=k>if</span> <span class=n>verify</span><span class=p>(</span><span class=n>question</span><span class=p>,</span> <span class=n>c</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 返回第一个通过验证的答案</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>verified</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=k>if</span> <span class=n>verified</span> <span class=k>else</span> <span class=n>candidates</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span></span></span></code></pre></div><hr><h2 id=七实战案例构建数学推理系统>七、实战案例：构建数学推理系统<a class=anchor href=#%e4%b8%83%e5%ae%9e%e6%88%98%e6%a1%88%e4%be%8b%e6%9e%84%e5%bb%ba%e6%95%b0%e5%ad%a6%e6%8e%a8%e7%90%86%e7%b3%bb%e7%bb%9f>#</a></h2><h3 id=完整代码示例>完整代码示例<a class=anchor href=#%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>torch</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>transformers</span> <span class=kn>import</span> <span class=n>AutoModelForCausalLM</span><span class=p>,</span> <span class=n>AutoTokenizer</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MathReasoningSystem</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>model_name</span><span class=o>=</span><span class=s2>&#34;deepseek-ai/deepseek-math-7b&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>model</span> <span class=o>=</span> <span class=n>AutoModelForCausalLM</span><span class=o>.</span><span class=n>from_pretrained</span><span class=p>(</span><span class=n>model_name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>tokenizer</span> <span class=o>=</span> <span class=n>AutoTokenizer</span><span class=o>.</span><span class=n>from_pretrained</span><span class=p>(</span><span class=n>model_name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>solve_with_cot</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>problem</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;使用 Chain-of-Thought 解题&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>prompt</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;&#34;&#34;请一步步解决以下数学问题:
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>问题: </span><span class=si>{</span><span class=n>problem</span><span class=si>}</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>解答: 让我仔细思考:&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>inputs</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>tokenizer</span><span class=p>(</span><span class=n>prompt</span><span class=p>,</span> <span class=n>return_tensors</span><span class=o>=</span><span class=s2>&#34;pt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>outputs</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>generate</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=o>**</span><span class=n>inputs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>max_length</span><span class=o>=</span><span class=mi>512</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>temperature</span><span class=o>=</span><span class=mf>0.7</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>do_sample</span><span class=o>=</span><span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>tokenizer</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=n>outputs</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>solve_with_self_consistency</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>problem</span><span class=p>,</span> <span class=n>n</span><span class=o>=</span><span class=mi>5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;使用 Self-Consistency 提高准确率&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>answers</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 采样 N 次</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>solution</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>solve_with_cot</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>answer</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>extract_answer</span><span class=p>(</span><span class=n>solution</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>answers</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>answer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 多数投票</span>
</span></span><span class=line><span class=cl>        <span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>Counter</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Counter</span><span class=p>(</span><span class=n>answers</span><span class=p>)</span><span class=o>.</span><span class=n>most_common</span><span class=p>(</span><span class=mi>1</span><span class=p>)[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>extract_answer</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>solution</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;从解答中提取最终答案&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 简化实现: 提取最后一个数字</span>
</span></span><span class=line><span class=cl>        <span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl>        <span class=n>numbers</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>findall</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\d+&#39;</span><span class=p>,</span> <span class=n>solution</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>numbers</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=k>if</span> <span class=n>numbers</span> <span class=k>else</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用示例</span>
</span></span><span class=line><span class=cl><span class=n>system</span> <span class=o>=</span> <span class=n>MathReasoningSystem</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>problem</span> <span class=o>=</span> <span class=s2>&#34;如果一个班级有 25 名学生,老师要把他们分成 5 组,每组多少人?&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 方法1: 单次CoT</span>
</span></span><span class=line><span class=cl><span class=n>answer1</span> <span class=o>=</span> <span class=n>system</span><span class=o>.</span><span class=n>solve_with_cot</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;CoT答案:&#34;</span><span class=p>,</span> <span class=n>answer1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 方法2: Self-Consistency</span>
</span></span><span class=line><span class=cl><span class=n>answer2</span> <span class=o>=</span> <span class=n>system</span><span class=o>.</span><span class=n>solve_with_self_consistency</span><span class=p>(</span><span class=n>problem</span><span class=p>,</span> <span class=n>n</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Self-Consistency答案:&#34;</span><span class=p>,</span> <span class=n>answer2</span><span class=p>)</span></span></span></code></pre></div><hr><h2 id=八关键技术对比总结>八、关键技术对比总结<a class=anchor href=#%e5%85%ab%e5%85%b3%e9%94%ae%e6%8a%80%e6%9c%af%e5%af%b9%e6%af%94%e6%80%bb%e7%bb%93>#</a></h2><h3 id=推理技术演进路线>推理技术演进路线<a class=anchor href=#%e6%8e%a8%e7%90%86%e6%8a%80%e6%9c%af%e6%bc%94%e8%bf%9b%e8%b7%af%e7%ba%bf>#</a></h3><pre class=mermaid>graph LR
    A[Direct Answer&lt;br/&gt;直接输出] --&gt; B[CoT&lt;br/&gt;单条思维链]
    B --&gt; C[Self-Consistency&lt;br/&gt;多路径投票]
    C --&gt; D[ToT&lt;br/&gt;树形搜索]
    D --&gt; E[MCTS&lt;br/&gt;蒙特卡洛树搜索]
    E --&gt; F[O1/R1&lt;br/&gt;RL强化推理]</pre><h3 id=各技术适用场景>各技术适用场景<a class=anchor href=#%e5%90%84%e6%8a%80%e6%9c%af%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h3><table><thead><tr><th>技术</th><th>计算成本</th><th>准确率提升</th><th>适用场景</th><th>是否需要训练</th></tr></thead><tbody><tr><td><strong>CoT</strong></td><td>1x</td><td>+5-10%</td><td>所有推理任务</td><td>否 (Prompt即可)</td></tr><tr><td><strong>Self-Consistency</strong></td><td>5-10x</td><td>+10-20%</td><td>不确定性高的任务</td><td>否</td></tr><tr><td><strong>ToT</strong></td><td>10-20x</td><td>+15-25%</td><td>需要规划的任务</td><td>否</td></tr><tr><td><strong>Best-of-N</strong></td><td>Nx</td><td>+20-30%</td><td>有验证器的任务</td><td>否</td></tr><tr><td><strong>MCTS</strong></td><td>50-100x</td><td>+25-35%</td><td>复杂博弈/规划</td><td>需要Value Model</td></tr><tr><td><strong>O1/R1</strong></td><td>10-50x</td><td>+40-60%</td><td>数学、代码、逻辑</td><td>需要大规模RL训练</td></tr></tbody></table><hr><h2 id=九未来展望与研究方向>九、未来展望与研究方向<a class=anchor href=#%e4%b9%9d%e6%9c%aa%e6%9d%a5%e5%b1%95%e6%9c%9b%e4%b8%8e%e7%a0%94%e7%a9%b6%e6%96%b9%e5%90%91>#</a></h2><h3 id=1-开放问题>1. 开放问题<a class=anchor href=#1-%e5%bc%80%e6%94%be%e9%97%ae%e9%a2%98>#</a></h3><ul><li><strong>可解释性</strong>: 思维链是否真的反映模型内部推理过程?</li><li><strong>效率优化</strong>: 如何在保持准确率的同时降低推理成本?</li><li><strong>泛化能力</strong>: 数学推理能力能否迁移到其他领域?</li></ul><h3 id=2-前沿研究方向>2. 前沿研究方向<a class=anchor href=#2-%e5%89%8d%e6%b2%bf%e7%a0%94%e7%a9%b6%e6%96%b9%e5%90%91>#</a></h3><ol><li><strong>混合推理系统</strong>: 结合符号推理与神经网络</li><li><strong>自适应推理</strong>: 根据问题难度动态调整推理深度</li><li><strong>多模态推理</strong>: 将推理能力扩展到图像、视频等模态</li></ol><h3 id=3-工程实践建议>3. 工程实践建议<a class=anchor href=#3-%e5%b7%a5%e7%a8%8b%e5%ae%9e%e8%b7%b5%e5%bb%ba%e8%ae%ae>#</a></h3><p><strong>选择合适的技术栈</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 简单任务 (闲聊、翻译)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>task_complexity</span> <span class=o>==</span> <span class=s2>&#34;low&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>use_direct_generation</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 中等任务 (简单数学、代码)</span>
</span></span><span class=line><span class=cl><span class=k>elif</span> <span class=n>task_complexity</span> <span class=o>==</span> <span class=s2>&#34;medium&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>use_cot_prompting</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 如果准确率不够, 加上 self_consistency()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 复杂任务 (奥赛数学、复杂规划)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>has_verifier</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>use_best_of_n</span><span class=p>(</span><span class=n>n</span><span class=o>=</span><span class=mi>64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>use_tree_of_thoughts</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 终极方案: 训练自己的推理模型</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>budget_is_large</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>train_reasoning_model_with_rl</span><span class=p>()</span></span></span></code></pre></div><hr><h2 id=十参考资源>十、参考资源<a class=anchor href=#%e5%8d%81%e5%8f%82%e8%80%83%e8%b5%84%e6%ba%90>#</a></h2><h3 id=论文>论文<a class=anchor href=#%e8%ae%ba%e6%96%87>#</a></h3><ol><li><p><strong>Chain-of-Thought</strong>:</p><ul><li><em>Chain-of-Thought Prompting Elicits Reasoning in Large Language Models</em> (Wei et al., 2022)</li><li><em>Self-Consistency Improves Chain of Thought Reasoning</em> (Wang et al., 2023)</li></ul></li><li><p><strong>Process Reward Models</strong>:</p><ul><li><em>Let&rsquo;s Verify Step by Step</em> (Lightman et al., 2023) - OpenAI PRM论文</li></ul></li><li><p><strong>DeepSeek-R1</strong>:</p><ul><li><em>DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</em> (DeepSeek, 2025)</li></ul></li><li><p><strong>Test-Time Compute</strong>:</p><ul><li><em>Scaling LLM Test-Time Compute Optimally can be More Effective than Scaling Model Parameters</em> (Snell et al., 2024)</li></ul></li></ol><h3 id=开源项目>开源项目<a class=anchor href=#%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae>#</a></h3><ul><li><strong>DeepSeek-R1</strong>: <a href=https://github.com/deepseek-ai/DeepSeek-R1>https://github.com/deepseek-ai/DeepSeek-R1</a></li><li><strong>Tree-of-Thoughts</strong>: <a href=https://github.com/princeton-nlp/tree-of-thought-llm>https://github.com/princeton-nlp/tree-of-thought-llm</a></li><li><strong>OpenAI PRM800K</strong>: <a href=https://github.com/openai/prm800k>https://github.com/openai/prm800k</a></li></ul><h3 id=实用工具>实用工具<a class=anchor href=#%e5%ae%9e%e7%94%a8%e5%b7%a5%e5%85%b7>#</a></h3><ul><li><strong>推理模型API</strong>: OpenAI o1, DeepSeek-R1</li><li><strong>本地部署</strong>: vLLM, TensorRT-LLM (支持推理优化)</li><li><strong>评估工具</strong>: MATH dataset, GSM8K, AIME</li></ul><hr><h2 id=本章总结>本章总结<a class=anchor href=#%e6%9c%ac%e7%ab%a0%e6%80%bb%e7%bb%93>#</a></h2><p>推理模型代表了大模型发展的新方向:<strong>从快速直觉到慢速逻辑</strong>。</p><p><strong>核心要点</strong>:</p><ol><li><strong>理论基础</strong>: CoT 通过边际化中间步骤提高准确率</li><li><strong>算法进化</strong>: Direct → CoT → Self-Consistency → ToT → MCTS → RL</li><li><strong>两大流派</strong>: OpenAI O1 (闭源 + PRM) vs DeepSeek-R1 (开源 + GRPO)</li><li><strong>关键技术</strong>: Process Reward Model, GRPO, Rejection Sampling</li><li><strong>工程实践</strong>: 根据任务复杂度选择合适的推理策略</li></ol><p><strong>最重要的洞察</strong>: 推理能力不是玄学,而是可以通过<strong>强化学习 + 验证器</strong>系统化地训练出来的。DeepSeek-R1 的成功证明了,即使是中小团队,也能在推理模型这条赛道上做出世界级的工作。</p><p>DeepMind 的研究表明:<strong>推理预算 (Compute Budget)</strong> 是继参数量、数据量之后的第三个 Scaling 维度。通过 ToT/MCTS/RL，我们让 LLM 从 &ldquo;基于检索的直觉&rdquo; 进化为 &ldquo;基于搜索的逻辑&rdquo;。</p><hr><p><strong>下一章预告</strong>: 第5章 - 模型安全与可解释性</p><p>在下一章中，探讨如何给 AI 装上"刹车"（Safety）和"显微镜"（Interpretability），包括 Prompt Injection 防御、机械可解释性以及稀疏自编码器（SAE）实战。</p></article><div style="margin-top:2rem;border-top:1px solid #e5e7eb;padding-top:1rem;font-size:.85rem;color:#6b7280;text-align:center">[统计组件仅在生产环境显示]</div><div class=giscus style=margin-top:2rem></div><script src=https://giscus.app/client.js data-repo=LordFoxFairy/LordFoxFairy.github.io data-repo-id=R_kgDOQ-JRGA data-category=Announcements data-category-id=DIC_kwDOQ-JRGM4C1PDC data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC3%E7%AB%A0_%E6%8E%A8%E7%90%86%E5%8A%A0%E9%80%9F%E9%BB%91%E7%A7%91%E6%8A%80/ class="flex align-center"><img src=/icons/backward.svg class=book-icon alt=Backward>
<span>第3章 推理加速黑科技</span>
</a></span><span><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC5%E7%AB%A0_%E6%A8%A1%E5%9E%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%8F%AF%E8%A7%A3%E9%87%8A%E6%80%A7/ class="flex align-center"><span>第5章 模型安全与可解释性</span>
<img src=/icons/forward.svg class=book-icon alt=Forward></a></span></div><div class=book-comments></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#目录>目录</a></li><li><a href=#一推理模型的理论基础>一、推理模型的理论基础</a><ul><li><a href=#1-什么是推理模型>1. 什么是推理模型?</a><ul><li><a href=#快速推理-vs-深度推理>快速推理 vs 深度推理</a></li></ul></li><li><a href=#2-chain-of-thought-cot-的数学原理>2. Chain-of-Thought (CoT) 的数学原理</a><ul><li><a href=#21-传统生成-vs-cot生成>2.1 传统生成 vs CoT生成</a></li><li><a href=#22-为什么cot有效-概率视角>2.2 为什么CoT有效? 概率视角</a></li><li><a href=#23-self-consistency-cot的增强版>2.3 Self-Consistency: CoT的增强版</a></li></ul></li></ul></li><li><a href=#二推理时计算增强-test-time-compute>二、推理时计算增强 (Test-Time Compute)</a><ul><li><a href=#1-推理时计算新的-scaling-law>1. 推理时计算：新的 Scaling Law</a><ul><li><a href=#从训练时到推理时的范式转变>从训练时到推理时的范式转变</a></li><li><a href=#2-数学基础搜索算法>2. 数学基础：搜索算法</a></li></ul></li></ul></li><li><a href=#三高级推理算法实战>三、高级推理算法实战</a><ul><li><a href=#1-tree-of-thoughts-tot>1. Tree-of-Thoughts (ToT)</a></li><li><a href=#2-best-of-n-rejection-sampling>2. Best-of-N (Rejection Sampling)</a></li><li><a href=#3-mcts-蒙特卡洛树搜索>3. MCTS (蒙特卡洛树搜索)</a><ul><li><a href=#mcts-四步循环>MCTS 四步循环</a></li><li><a href=#ucb-upper-confidence-bound-公式>UCB (Upper Confidence Bound) 公式</a></li></ul></li></ul></li><li><a href=#四openai-o1闭源先锋>四、OpenAI O1：闭源先锋</a><ul><li><a href=#1-核心架构推测>1. 核心架构推测</a></li><li><a href=#2-prm-vs-orm-两种奖励模型对比>2. PRM vs ORM: 两种奖励模型对比</a><ul><li><a href=#prm-的训练流程>PRM 的训练流程</a></li></ul></li><li><a href=#3-o1-的效果与代价>3. O1 的效果与代价</a></li></ul></li><li><a href=#五deepseek-r1开源界的盗火者>五、DeepSeek-R1：开源界的"盗火者"</a><ul><li><a href=#1-r1-zero从零开始的奇迹>1. R1-Zero：从零开始的奇迹</a></li><li><a href=#2-核心算法grpo-group-relative-policy-optimization>2. 核心算法：GRPO (Group Relative Policy Optimization)</a><ul><li><a href=#grpo-完整数学推导>GRPO 完整数学推导</a></li><li><a href=#pytorch-完整实现>PyTorch 完整实现</a></li><li><a href=#grpo-vs-ppo-对比>GRPO vs PPO 对比</a></li></ul></li><li><a href=#3-蒸馏-distillationr1-给小模型的礼物>3. &ldquo;蒸馏&rdquo; (Distillation)：R1 给小模型的礼物</a></li></ul></li><li><a href=#六复现-r1-的完整路线图>六、复现 R1 的完整路线图</a><ul><li><a href=#阶段1-冷启动-cold-start---deepseek-r1-的关键发现>阶段1: 冷启动 (Cold Start) - DeepSeek-R1 的关键发现</a><ul><li><a href=#为什么-cold-start-数据至关重要>为什么 Cold Start 数据至关重要？</a></li><li><a href=#cold-start-数据的质量标准>Cold Start 数据的质量标准</a></li></ul></li><li><a href=#阶段2-推理增强-rl>阶段2: 推理增强 (RL)</a></li><li><a href=#阶段3-拒绝采样-rejection-sampling>阶段3: 拒绝采样 (Rejection Sampling)</a></li></ul></li><li><a href=#七实战案例构建数学推理系统>七、实战案例：构建数学推理系统</a><ul><li><a href=#完整代码示例>完整代码示例</a></li></ul></li><li><a href=#八关键技术对比总结>八、关键技术对比总结</a><ul><li><a href=#推理技术演进路线>推理技术演进路线</a></li><li><a href=#各技术适用场景>各技术适用场景</a></li></ul></li><li><a href=#九未来展望与研究方向>九、未来展望与研究方向</a><ul><li><a href=#1-开放问题>1. 开放问题</a></li><li><a href=#2-前沿研究方向>2. 前沿研究方向</a></li><li><a href=#3-工程实践建议>3. 工程实践建议</a></li></ul></li><li><a href=#十参考资源>十、参考资源</a><ul><li><a href=#论文>论文</a></li><li><a href=#开源项目>开源项目</a></li><li><a href=#实用工具>实用工具</a></li></ul></li><li><a href=#本章总结>本章总结</a></li></ul></nav></div></aside></main></body></html>