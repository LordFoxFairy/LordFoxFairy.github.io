<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='第九篇 Agent 架构设计# 本章摘要
引用吴恩达教授观点：Agentic Workflow 的未来在于 协作 (Collaboration)。本章将深入探讨 Multi-Agent Systems (MAS)，学习如何构建 去中心化 (Swarm)、分布式 (Distributed) 和 开放连接 (MCP) 的智能系统。
我们将采用 LangGraph 官方标准，废弃手写的轮子，聚焦于工业级的架构模式和最佳实践。
目录导航# 协作模式演进 (Patterns) Swarm 模式详解 (Official Way) 分布式协作 (Distributed State) 微服务化标准 (LangServe) 标准化工具协议 (MCP) 架构总结与选型指南 第1章：协作模式演进 (Patterns)# 1.1 吴恩达的四种 Agentic 模式# 在 2024 年的演讲中，Andrew Ng 总结了四种核心的 Agentic Workflow 模式：
graph TB subgraph "Pattern 1: Reflection" A1[Generate] --> A2[Self-Critique] --> A3[Revise] end subgraph "Pattern 2: Tool Use" B1[Reasoning] --> B2[Tool Call] --> B3[Integrate Results] end subgraph "Pattern 3: Planning" C1[Decompose] --> C2[Execute Steps] --> C3[Synthesize] end subgraph "Pattern 4: Multi-Agent" D1[Agent A] <--> D2[Agent B] D2 <--> D3[Agent C] D1 <--> D3 end style D1 fill:#e1f5ff style D2 fill:#e1f5ff style D3 fill:#e1f5ff本章聚焦 Pattern 4：Multi-Agent Collaboration（多智能体协作）。
'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://LordFoxFairy.github.io/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B9%9D%E7%AF%87-agent-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"><meta property="og:site_name" content="LordFoxFairy的笔记本"><meta property="og:title" content="第九篇 Agent 架构设计"><meta property="og:description" content='第九篇 Agent 架构设计# 本章摘要
引用吴恩达教授观点：Agentic Workflow 的未来在于 协作 (Collaboration)。本章将深入探讨 Multi-Agent Systems (MAS)，学习如何构建 去中心化 (Swarm)、分布式 (Distributed) 和 开放连接 (MCP) 的智能系统。
我们将采用 LangGraph 官方标准，废弃手写的轮子，聚焦于工业级的架构模式和最佳实践。
目录导航# 协作模式演进 (Patterns) Swarm 模式详解 (Official Way) 分布式协作 (Distributed State) 微服务化标准 (LangServe) 标准化工具协议 (MCP) 架构总结与选型指南 第1章：协作模式演进 (Patterns)# 1.1 吴恩达的四种 Agentic 模式# 在 2024 年的演讲中，Andrew Ng 总结了四种核心的 Agentic Workflow 模式：
graph TB subgraph "Pattern 1: Reflection" A1[Generate] --> A2[Self-Critique] --> A3[Revise] end subgraph "Pattern 2: Tool Use" B1[Reasoning] --> B2[Tool Call] --> B3[Integrate Results] end subgraph "Pattern 3: Planning" C1[Decompose] --> C2[Execute Steps] --> C3[Synthesize] end subgraph "Pattern 4: Multi-Agent" D1[Agent A] <--> D2[Agent B] D2 <--> D3[Agent C] D1 <--> D3 end style D1 fill:#e1f5ff style D2 fill:#e1f5ff style D3 fill:#e1f5ff本章聚焦 Pattern 4：Multi-Agent Collaboration（多智能体协作）。'><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="notebooks"><meta itemprop=name content="第九篇 Agent 架构设计"><meta itemprop=description content='第九篇 Agent 架构设计# 本章摘要
引用吴恩达教授观点：Agentic Workflow 的未来在于 协作 (Collaboration)。本章将深入探讨 Multi-Agent Systems (MAS)，学习如何构建 去中心化 (Swarm)、分布式 (Distributed) 和 开放连接 (MCP) 的智能系统。
我们将采用 LangGraph 官方标准，废弃手写的轮子，聚焦于工业级的架构模式和最佳实践。
目录导航# 协作模式演进 (Patterns) Swarm 模式详解 (Official Way) 分布式协作 (Distributed State) 微服务化标准 (LangServe) 标准化工具协议 (MCP) 架构总结与选型指南 第1章：协作模式演进 (Patterns)# 1.1 吴恩达的四种 Agentic 模式# 在 2024 年的演讲中，Andrew Ng 总结了四种核心的 Agentic Workflow 模式：
graph TB subgraph "Pattern 1: Reflection" A1[Generate] --> A2[Self-Critique] --> A3[Revise] end subgraph "Pattern 2: Tool Use" B1[Reasoning] --> B2[Tool Call] --> B3[Integrate Results] end subgraph "Pattern 3: Planning" C1[Decompose] --> C2[Execute Steps] --> C3[Synthesize] end subgraph "Pattern 4: Multi-Agent" D1[Agent A] <--> D2[Agent B] D2 <--> D3[Agent C] D1 <--> D3 end style D1 fill:#e1f5ff style D2 fill:#e1f5ff style D3 fill:#e1f5ff本章聚焦 Pattern 4：Multi-Agent Collaboration（多智能体协作）。'><meta itemprop=wordCount content="1997"><title>第九篇 Agent 架构设计 | LordFoxFairy的笔记本</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://LordFoxFairy.github.io/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B9%9D%E7%AF%87-agent-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/><link rel=stylesheet href=/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG+T2l66Bw7pV8=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.a7a11a812549b6c20d4eeaf4a5a8317847527505f7a0ad3e6824fb320b3128a8.js integrity="sha256-p6EagSVJtsINTur0pagxeEdSdQX3oK0+aCT7MgsxKKg=" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-notebooks"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>LordFoxFairy的笔记本</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-8410cdd8ef137d6cb143c08e6db6ba10 class=toggle checked>
<label for=section-8410cdd8ef137d6cb143c08e6db6ba10 class=flex><a role=button>LangChain笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%9F%BA%E7%A1%80%E8%AE%A4%E7%9F%A5/>第一篇 基础认知</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E5%AE%9E%E6%88%98/>第二篇 快速上手实战</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AF%87-langgraph-%E6%B7%B1%E5%85%A5/>第三篇 LangGraph 深入</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-rag%E5%9F%BA%E7%A1%80%E7%AF%87langchain%E7%AF%87/>第四篇 RAG基础篇(LangChain篇)</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-rag%E5%9F%BA%E7%A1%80%E7%AF%87llamaindex%E7%AF%87/>第四篇 RAG基础篇(LlamaIndex篇)</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AF%87-rag%E9%AB%98%E7%BA%A7%E7%AF%87langchain%E7%AF%87/>第五篇 RAG高级篇(LangChain篇)</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AF%87-rag%E9%AB%98%E7%BA%A7%E7%AF%87llamaindex%E7%AF%87/>第五篇 RAG高级篇(LlamaIndex篇)</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AF%87-%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/>第六篇 文档处理与数据清洗</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E7%AF%87-deep-agents/>第七篇 Deep Agents</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AF%87-middleware-%E5%B7%A5%E7%A8%8B%E5%8C%96/>第八篇 Middleware 工程化</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B9%9D%E7%AF%87-agent-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ class=active>第九篇 Agent 架构设计</a></li><li><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%8D%81%E7%AF%87-%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%9B%91%E6%8E%A7%E8%AF%84%E4%BC%B0/>第十篇 生产实践与监控评估</a></li><li><input type=checkbox id=section-a3e9b1811e5a21dbfddb0753f565cedb class=toggle>
<label for=section-a3e9b1811e5a21dbfddb0753f565cedb class=flex><a role=button>assets</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li><li><input type=checkbox id=section-9a64553a000534ad3c81a611c6c29ec2 class=toggle>
<label for=section-9a64553a000534ad3c81a611c6c29ec2 class=flex><a role=button>code</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><input type=checkbox id=section-6fad2589acfdd5d6a1fb55beb392fb77 class=toggle>
<label for=section-6fad2589acfdd5d6a1fb55beb392fb77 class=flex><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/code/fasta2a/>fasta2a</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li></ul></li></ul></li><li><input type=checkbox id=section-ce33306d44f9ed4d296b9a79329bed1c class=toggle>
<label for=section-ce33306d44f9ed4d296b9a79329bed1c class=flex><a role=button>图像算法笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AF%87_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/>第一篇 机器学习基础</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/>第二篇 深度学习基础</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AF%87_%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/>第三篇 计算机视觉核心技术</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8Eyolo%E7%B3%BB%E5%88%97/>第四篇 目标检测与YOLO系列</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AF%87_%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/>第五篇 图像分割</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AF%87_%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/>第六篇 生成模型</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E7%AF%87_%E8%A7%86%E8%A7%89%E5%A4%A7%E6%A8%A1%E5%9E%8B/>第七篇 视觉大模型</a></li><li><a href=/notebooks/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AF%87_%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5/>第八篇 生产实践</a></li></ul></li><li><input type=checkbox id=section-77f5db9e44a9af6dab4403b49a65334f class=toggle>
<label for=section-77f5db9e44a9af6dab4403b49a65334f class=flex><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/>大模型笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><input type=checkbox id=section-db59738de306cbbe384ad7fbd5cf11b5 class=toggle>
<label for=section-db59738de306cbbe384ad7fbd5cf11b5 class=flex><a role=button>第一部分：大语言模型基础</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/%E7%AC%AC1%E7%AB%A0_%E5%88%9D%E8%AF%86%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/>第1章 初识大语言模型</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/%E7%AC%AC2%E7%AB%A0_%E4%B8%8E%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%AF%9D%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/>第2章 与模型对话：提示工程基础</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/%E7%AC%AC3%E7%AB%A0_%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E7%9F%B3%E5%88%86%E8%AF%8D%E4%B8%8E%E5%B5%8C%E5%85%A5/>第3章 语言的基石：分词与嵌入</a></li></ul></li><li><input type=checkbox id=section-30b17899e420f6a53aa6e578440dd132 class=toggle>
<label for=section-30b17899e420f6a53aa6e578440dd132 class=flex><a role=button>第二部分：Transformer架构揭秘</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86transformer%E6%9E%B6%E6%9E%84%E6%8F%AD%E7%A7%98/%E7%AC%AC1%E7%AB%A0_transformer%E6%A0%B8%E5%BF%83%E6%8F%AD%E7%A7%98/>第1章 Transformer核心揭秘</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86transformer%E6%9E%B6%E6%9E%84%E6%8F%AD%E7%A7%98/%E7%AC%AC2%E7%AB%A0_%E6%A8%A1%E5%9E%8B%E5%AE%B6%E6%97%8F%E8%B0%B1%E7%B3%BB%E4%BB%8E%E7%BC%96%E7%A0%81%E5%99%A8%E5%88%B0%E8%A7%A3%E7%A0%81%E5%99%A8/>第2章 模型家族谱系：从编码器到解码器</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86transformer%E6%9E%B6%E6%9E%84%E6%8F%AD%E7%A7%98/%E7%AC%AC3%E7%AB%A0_%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84%E5%A5%A5%E7%A7%98%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%88%B0%E6%99%BA%E8%83%BD/>第3章 预训练的奥秘：从数据到智能</a></li></ul></li><li><input type=checkbox id=section-da88ac5e3d01ea6f4b2996cb87ecf19f class=toggle>
<label for=section-da88ac5e3d01ea6f4b2996cb87ecf19f class=flex><a role=button>第三部分：数据工程与定制化</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%9A%E5%88%B6%E5%8C%96/%E7%AC%AC1%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/>第1章 数据工程基础</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%9A%E5%88%B6%E5%8C%96/%E7%AC%AC2%E7%AB%A0_%E5%BE%AE%E8%B0%83%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9E%E6%A8%A1%E5%9E%8B/>第2章 微调你的专属模型</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%9A%E5%88%B6%E5%8C%96/%E7%AC%AC3%E7%AB%A0_%E4%B8%8E%E4%BA%BA%E7%B1%BB%E5%AF%B9%E9%BD%90%E5%81%8F%E5%A5%BD%E4%BC%98%E5%8C%96/>第3章 与人类对齐：偏好优化</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%9A%E5%88%B6%E5%8C%96/%E7%AC%AC4%E7%AB%A0_%E5%88%9B%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84%E5%B5%8C%E5%85%A5%E6%A8%A1%E5%9E%8B/>第4章 创建更优的嵌入模型</a></li></ul></li><li><input type=checkbox id=section-81f0a7a10bc544ea0e1fd883e2a436eb class=toggle>
<label for=section-81f0a7a10bc544ea0e1fd883e2a436eb class=flex><a role=button>第四部分：大模型应用开发</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E7%AC%AC1%E7%AB%A0_%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AD%A6%E4%B9%A0/>第1章 提示工程与上下文学习</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E7%AC%AC2%E7%AB%A0_%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90rag%E5%8E%9F%E7%90%86/>第2章 检索增强生成（RAG）原理</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E7%AC%AC3%E7%AB%A0_%E6%99%BA%E8%83%BD%E4%BD%93agent%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/>第3章 智能体（Agent）核心机制</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E7%AC%AC4%E7%AB%A0_%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86/>第4章 多模态大模型原理</a></li></ul></li><li><input type=checkbox id=section-0509decfe880d3d2074947902aea8022 class=toggle>
<label for=section-0509decfe880d3d2074947902aea8022 class=flex><a role=button>第五部分：工程实战工具栈</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%B7%A5%E5%85%B7%E6%A0%88/%E7%AC%AC1%E7%AB%A0_hugging_face%E7%94%9F%E6%80%81%E5%85%A8%E6%99%AF/>第1章 Hugging Face生态全景</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%B7%A5%E5%85%B7%E6%A0%88/%E7%AC%AC2%E7%AB%A0_llama-factory%E5%BE%AE%E8%B0%83%E5%B7%A5%E5%8E%82/>第2章 LLaMA-Factory微调工厂</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%B7%A5%E5%85%B7%E6%A0%88/%E7%AC%AC3%E7%AB%A0_trl%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/>第3章 TRL与强化学习实战</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%B7%A5%E5%85%B7%E6%A0%88/%E7%AC%AC4%E7%AB%A0_deepspeed%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/>第4章 DeepSpeed分布式训练</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E5%B7%A5%E5%85%B7%E6%A0%88/%E7%AC%AC5%E7%AB%A0_%E7%AB%AF%E5%88%B0%E7%AB%AFllm%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/>第5章 端到端LLM项目实战</a></li></ul></li><li><input type=checkbox id=section-dc465ed94a0f7fb78440cab8a8a2a28b class=toggle>
<label for=section-dc465ed94a0f7fb78440cab8a8a2a28b class=flex><a role=button>第六部分：生产部署与评估</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%AF%84%E4%BC%B0/%E7%AC%AC1%E7%AB%A0_%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%8E%A8%E7%90%86%E5%8A%A0%E9%80%9F/>第1章 模型压缩与推理加速</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%AF%84%E4%BC%B0/%E7%AC%AC2%E7%AB%A0_vllm%E9%AB%98%E6%80%A7%E8%83%BD%E6%8E%A8%E7%90%86/>第2章 vLLM高性能推理</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%AF%84%E4%BC%B0/%E7%AC%AC3%E7%AB%A0_%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%BD%93%E7%B3%BB/>第3章 模型评估体系</a></li></ul></li><li><input type=checkbox id=section-54ec04ac2cdda7238de2ed38f0bcb7b1 class=toggle>
<label for=section-54ec04ac2cdda7238de2ed38f0bcb7b1 class=flex><a role=button>第七部分：高级技术专题</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0_%E9%95%BF%E4%B8%8A%E4%B8%8B%E6%96%87%E6%8A%80%E6%9C%AF/>第1章 长上下文技术</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC2%E7%AB%A0_%E6%96%B0%E5%9E%8B%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/>第2章 新型架构探索</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC3%E7%AB%A0_%E6%8E%A8%E7%90%86%E5%8A%A0%E9%80%9F%E9%BB%91%E7%A7%91%E6%8A%80/>第3章 推理加速黑科技</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC4%E7%AB%A0_%E6%8E%A8%E7%90%86%E6%A8%A1%E5%9E%8B%E4%B8%93%E9%A2%98/>第4章 推理模型专题</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%AC%AC5%E7%AB%A0_%E6%A8%A1%E5%9E%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%8F%AF%E8%A7%A3%E9%87%8A%E6%80%A7/>第5章 模型安全与可解释性</a></li></ul></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/glossary/>GLOSSARY</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/roadmap/>ROADMAP</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/summary/>SUMMARY</a></li><li><a href=/notebooks/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/%E5%AE%8C%E7%BB%93%E6%8A%A5%E5%91%8A/>完结报告</a></li></ul></li><li><input type=checkbox id=section-7177254393287994b491879262a62a06 class=toggle>
<label for=section-7177254393287994b491879262a62a06 class=flex><a role=button>实践笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/2.-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-fastapi/>深入理解 FastAPI</a></li><li><a href=/notebooks/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/4.-agent%E6%9C%80%E4%BD%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>Agent最佳设计模式</a></li></ul></li><li><input type=checkbox id=section-0172eb8516eeb7b4e657f3949a135c25 class=toggle>
<label for=section-0172eb8516eeb7b4e657f3949a135c25 class=flex><a role=button>机器学习笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC01%E7%AB%A0_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/>第01章 机器学习概览</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC02%E7%AB%A0_%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%E4%B8%8E%E5%BE%AE%E7%A7%AF%E5%88%86/>第02章 矩阵运算与微积分</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC03%E7%AB%A0_svd%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/>第03章 SVD与矩阵分解</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC04%E7%AB%A0_%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83_%E6%8C%87%E6%95%B0%E6%97%8F%E4%B8%8E%E5%85%B1%E8%BD%AD%E5%85%88%E9%AA%8C/>第04章 概率分布 指数族与共轭先验</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC05%E7%AB%A0_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/>第05章 线性回归</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC06%E7%AB%A0_%E6%84%9F%E7%9F%A5%E6%9C%BA/>第06章 感知机</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC07%E7%AB%A0_%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BAsvm/>第07章 支持向量机(SVM)</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC08%E7%AB%A0_%E6%A0%B8%E6%96%B9%E6%B3%95/>第08章 核方法</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC09%E7%AB%A0_%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/>第09章 决策树与集成学习</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/>第10章 逻辑回归与最大熵模型</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E7%AB%A0_%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8Bglm/>第11章 广义线性模型(GLM)</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E7%AB%A0_%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B_%E8%A1%A8%E7%A4%BA/>第13章 概率图模型 表示</a></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E7%AB%A0_%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B_%E6%8E%A8%E6%96%AD/>第14章 概率图模型 推断</a></li><li><input type=checkbox id=section-b17efd79c46843a887113a063f929150 class=toggle>
<label for=section-b17efd79c46843a887113a063f929150 class=flex><a role=button>assets</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li><li><a href=/notebooks/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/skills/>skills</a></li></ul></li><li><input type=checkbox id=section-29762f225235d2ac19b613cc28b093c8 class=toggle>
<label for=section-29762f225235d2ac19b613cc28b093c8 class=flex><a href=/notebooks/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>深度学习笔记</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/notebooks/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC1%E7%AB%A0_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/>第1章 深度学习基础</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/icons/menu.svg class=book-icon alt=Menu></label><h3>第九篇 Agent 架构设计</h3><label for=toc-control><img src=/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#目录导航>目录导航</a></li><li><a href=#第1章协作模式演进-patterns>第1章：协作模式演进 (Patterns)</a><ul><li><a href=#11-吴恩达的四种-agentic-模式>1.1 吴恩达的四种 Agentic 模式</a></li><li><a href=#12-架构演进从单体到生态>1.2 架构演进：从单体到生态</a></li></ul></li><li><a href=#第2章swarm-模式详解-official-way>第2章：Swarm 模式详解 (Official Way)</a><ul><li><a href=#21-核心定义swarm--蜂群算法>2.1 核心定义：Swarm ≠ 蜂群算法</a></li><li><a href=#22-官方推荐写法tool-based-routing>2.2 官方推荐写法：Tool-Based Routing</a><ul><li><a href=#221-实战场景保险理赔系统>2.2.1 实战场景：保险理赔系统</a></li><li><a href=#222-step-1-定义全局状态>2.2.2 Step 1: 定义全局状态</a></li><li><a href=#223-step-2-创建-transfer-工具>2.2.3 Step 2: 创建 Transfer 工具</a></li><li><a href=#224-step-3-定义-agent-节点>2.2.4 Step 3: 定义 Agent 节点</a></li><li><a href=#225-step-4-构建路由图>2.2.5 Step 4: 构建路由图</a></li><li><a href=#226-运行测试>2.2.6 运行测试</a></li></ul></li><li><a href=#23-swarm-模式总结>2.3 Swarm 模式总结</a></li></ul></li><li><a href=#第3章分布式协作-distributed-state>第3章：分布式协作 (Distributed State)</a><ul><li><a href=#31-问题swarm-的单点瓶颈>3.1 问题：Swarm 的单点瓶颈</a></li><li><a href=#32-解决方案shared-state-via-database>3.2 解决方案：Shared State via Database</a></li><li><a href=#33-实战redis-checkpointer>3.3 实战：Redis Checkpointer</a><ul><li><a href=#331-安装依赖>3.3.1 安装依赖</a></li><li><a href=#332-修改代码启用持久化>3.3.2 修改代码：启用持久化</a></li><li><a href=#333-分布式运行>3.3.3 分布式运行</a></li></ul></li><li><a href=#34-thread-id分布式协作的钥匙>3.4 Thread ID：分布式协作的钥匙</a></li><li><a href=#35-分布式架构图>3.5 分布式架构图</a></li></ul></li><li><a href=#第4章微服务化标准-langserve>第4章：微服务化标准 (LangServe)</a><ul><li><a href=#41-为什么需要-langserve>4.1 为什么需要 LangServe？</a></li><li><a href=#42-核心-apiadd_routes>4.2 核心 API：add_routes</a></li><li><a href=#43-实战暴露保险-swarm>4.3 实战：暴露保险 Swarm</a></li><li><a href=#44-客户端调用remoterunnable>4.4 客户端调用：RemoteRunnable</a></li><li><a href=#45-langserve-的高级特性>4.5 LangServe 的高级特性</a></li><li><a href=#46-langserve-vs-手写-fastapi>4.6 LangServe vs 手写 FastAPI</a></li></ul></li><li><a href=#第5章标准化工具协议-mcp>第5章：标准化工具协议 (MCP)</a><ul><li><a href=#51-mcp-的定位>5.1 MCP 的定位</a></li><li><a href=#52-mcp-架构原理>5.2 MCP 架构原理</a></li><li><a href=#53-mcp-的三种原语>5.3 MCP 的三种原语</a></li><li><a href=#54-实战构建-sqlite-mcp-server>5.4 实战：构建 SQLite MCP Server</a><ul><li><a href=#541-服务端实现>5.4.1 服务端实现</a></li><li><a href=#542-客户端调用>5.4.2 客户端调用</a></li></ul></li><li><a href=#55-mcp-的生态优势>5.5 MCP 的生态优势</a></li><li><a href=#56-mcp-vs-直接调用-api>5.6 MCP vs 直接调用 API</a></li><li><a href=#57-mcp-与-swarm-的协作>5.7 MCP 与 Swarm 的协作</a></li></ul></li><li><a href=#第6章架构总结与选型指南>第6章：架构总结与选型指南</a><ul><li><a href=#61-技术栈对比>6.1 技术栈对比</a></li><li><a href=#62-选型决策树>6.2 选型决策树</a></li><li><a href=#63-典型架构模式>6.3 典型架构模式</a><ul><li><a href=#模式-1简单协作流程>模式 1：简单协作流程</a></li><li><a href=#模式-2高并发业务>模式 2：高并发业务</a></li><li><a href=#模式-3微服务生态>模式 3：微服务生态</a></li></ul></li><li><a href=#64-工程最佳实践>6.4 工程最佳实践</a><ul><li><a href=#1-死循环检测>1. 死循环检测</a></li><li><a href=#2-状态快照>2. 状态快照</a></li><li><a href=#3-分布式追踪>3. 分布式追踪</a></li><li><a href=#4-优雅降级>4. 优雅降级</a></li></ul></li><li><a href=#65-性能优化建议>6.5 性能优化建议</a></li><li><a href=#66-安全考虑>6.6 安全考虑</a></li></ul></li><li><a href=#结语架构的本质是控制复杂度>结语：架构的本质是控制复杂度</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=第九篇-agent-架构设计>第九篇 Agent 架构设计<a class=anchor href=#%e7%ac%ac%e4%b9%9d%e7%af%87-agent-%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1>#</a></h1><blockquote class=book-hint><p><strong>本章摘要</strong></p><p>引用吴恩达教授观点：Agentic Workflow 的未来在于 <strong>协作 (Collaboration)</strong>。本章将深入探讨 <strong>Multi-Agent Systems (MAS)</strong>，学习如何构建 <strong>去中心化 (Swarm)</strong>、<strong>分布式 (Distributed)</strong> 和 <strong>开放连接 (MCP)</strong> 的智能系统。</p><p>我们将采用 <strong>LangGraph 官方标准</strong>，废弃手写的轮子，聚焦于工业级的架构模式和最佳实践。</p></blockquote><h2 id=目录导航>目录导航<a class=anchor href=#%e7%9b%ae%e5%bd%95%e5%af%bc%e8%88%aa>#</a></h2><ol><li><strong>协作模式演进 (Patterns)</strong></li><li><strong>Swarm 模式详解 (Official Way)</strong></li><li><strong>分布式协作 (Distributed State)</strong></li><li><strong>微服务化标准 (LangServe)</strong></li><li><strong>标准化工具协议 (MCP)</strong></li><li><strong>架构总结与选型指南</strong></li></ol><hr><h2 id=第1章协作模式演进-patterns>第1章：协作模式演进 (Patterns)<a class=anchor href=#%e7%ac%ac1%e7%ab%a0%e5%8d%8f%e4%bd%9c%e6%a8%a1%e5%bc%8f%e6%bc%94%e8%bf%9b-patterns>#</a></h2><h3 id=11-吴恩达的四种-agentic-模式>1.1 吴恩达的四种 Agentic 模式<a class=anchor href=#11-%e5%90%b4%e6%81%a9%e8%be%be%e7%9a%84%e5%9b%9b%e7%a7%8d-agentic-%e6%a8%a1%e5%bc%8f>#</a></h3><p>在 2024 年的演讲中，Andrew Ng 总结了四种核心的 Agentic Workflow 模式：</p><pre class=mermaid>graph TB
    subgraph &#34;Pattern 1: Reflection&#34;
        A1[Generate] --&gt; A2[Self-Critique] --&gt; A3[Revise]
    end

    subgraph &#34;Pattern 2: Tool Use&#34;
        B1[Reasoning] --&gt; B2[Tool Call] --&gt; B3[Integrate Results]
    end

    subgraph &#34;Pattern 3: Planning&#34;
        C1[Decompose] --&gt; C2[Execute Steps] --&gt; C3[Synthesize]
    end

    subgraph &#34;Pattern 4: Multi-Agent&#34;
        D1[Agent A] &lt;--&gt; D2[Agent B]
        D2 &lt;--&gt; D3[Agent C]
        D1 &lt;--&gt; D3
    end

    style D1 fill:#e1f5ff
    style D2 fill:#e1f5ff
    style D3 fill:#e1f5ff</pre><script src=/mermaid.min.js></script><script>mermaid.initialize({flowchart:{useMaxWidth:!0},theme:"default"})</script><p><strong>本章聚焦</strong> Pattern 4：<strong>Multi-Agent Collaboration（多智能体协作）</strong>。</p><h3 id=12-架构演进从单体到生态>1.2 架构演进：从单体到生态<a class=anchor href=#12-%e6%9e%b6%e6%9e%84%e6%bc%94%e8%bf%9b%e4%bb%8e%e5%8d%95%e4%bd%93%e5%88%b0%e7%94%9f%e6%80%81>#</a></h3><pre class=mermaid>graph LR
    Stage1[Monolith&lt;br/&gt;单体Agent] --&gt;|复杂度提升| Stage2[Swarm&lt;br/&gt;进程内协作]
    Stage2 --&gt;|分布式需求| Stage3[Ecosystem&lt;br/&gt;微服务生态]

    subgraph &#34;Level 1: Monolith&#34;
        M[Single Agent&lt;br/&gt;+ Tools]
    end

    subgraph &#34;Level 2: Swarm&#34;
        S1[Triage Agent]
        S2[Fraud Agent]
        S3[Legal Agent]
        S1 -.handoff.-&gt; S2
        S1 -.handoff.-&gt; S3
    end

    subgraph &#34;Level 3: Ecosystem&#34;
        E1[Service A&lt;br/&gt;Python]
        E2[Service B&lt;br/&gt;Java]
        E3[MCP Tools]
        E1 --&gt;|HTTP| E2
        E1 --&gt;|MCP| E3
    end

    style S1 fill:#d4f1d4
    style S2 fill:#d4f1d4
    style S3 fill:#d4f1d4</pre><ol><li><strong>Monolith</strong>：单个 Agent 处理所有逻辑，受限于上下文窗口和推理复杂度。</li><li><strong>Swarm</strong>：多个专家 Agent 在同一进程中协作，通过 Handoff 机制移交控制权。</li><li><strong>Ecosystem</strong>：跨进程、跨语言的微服务架构，通过标准协议互联。</li></ol><hr><h2 id=第2章swarm-模式详解-official-way>第2章：Swarm 模式详解 (Official Way)<a class=anchor href=#%e7%ac%ac2%e7%ab%a0swarm-%e6%a8%a1%e5%bc%8f%e8%af%a6%e8%a7%a3-official-way>#</a></h2><h3 id=21-核心定义swarm--蜂群算法>2.1 核心定义：Swarm ≠ 蜂群算法<a class=anchor href=#21-%e6%a0%b8%e5%bf%83%e5%ae%9a%e4%b9%89swarm--%e8%9c%82%e7%be%a4%e7%ae%97%e6%b3%95>#</a></h3><p>在 LangGraph 语境下，<strong>Swarm</strong> 不是指分布式群体智能算法，而是指：</p><blockquote class=book-hint><p><strong>多个 Agent 通过 Handoffs（控制权移交）进行去中心化协作的设计模式。</strong></p></blockquote><p><strong>关键特性</strong>：</p><ul><li><strong>去中心化</strong>：没有中央路由器，每个 Agent 自己决定下一步该谁接手。</li><li><strong>Handoff</strong>：不只是返回结果，而是传递完整的上下文和控制权。</li><li><strong>共享状态</strong>：所有 Agent 操作同一个 State 对象。</li></ul><h3 id=22-官方推荐写法tool-based-routing>2.2 官方推荐写法：Tool-Based Routing<a class=anchor href=#22-%e5%ae%98%e6%96%b9%e6%8e%a8%e8%8d%90%e5%86%99%e6%b3%95tool-based-routing>#</a></h3><p>LangGraph 官方推荐的 Multi-Agent 实现方式是：<strong>定义 <code>transfer_to_X</code> 工具，通过 Tool Call 触发条件边跳转</strong>。</p><h4 id=221-实战场景保险理赔系统>2.2.1 实战场景：保险理赔系统<a class=anchor href=#221-%e5%ae%9e%e6%88%98%e5%9c%ba%e6%99%af%e4%bf%9d%e9%99%a9%e7%90%86%e8%b5%94%e7%b3%bb%e7%bb%9f>#</a></h4><p><strong>业务流程</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>用户提交理赔
</span></span><span class=line><span class=cl>  → Triage Agent (分流)
</span></span><span class=line><span class=cl>  → Claim Processor (初审)
</span></span><span class=line><span class=cl>  → 风控 Agent / 法务 Agent (专业处理)
</span></span><span class=line><span class=cl>  → 结案</span></span></code></pre></div><h4 id=222-step-1-定义全局状态>2.2.2 Step 1: 定义全局状态<a class=anchor href=#222-step-1-%e5%ae%9a%e4%b9%89%e5%85%a8%e5%b1%80%e7%8a%b6%e6%80%81>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>Annotated</span><span class=p>,</span> <span class=n>TypedDict</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langgraph.graph.message</span> <span class=kn>import</span> <span class=n>add_messages</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>InsuranceState</span><span class=p>(</span><span class=n>TypedDict</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;全局共享状态&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>messages</span><span class=p>:</span> <span class=n>Annotated</span><span class=p>[</span><span class=nb>list</span><span class=p>,</span> <span class=n>add_messages</span><span class=p>]</span>  <span class=c1># 对话历史（自动合并）</span>
</span></span><span class=line><span class=cl>    <span class=n>claim_id</span><span class=p>:</span> <span class=nb>str</span>                             <span class=c1># 案件ID</span>
</span></span><span class=line><span class=cl>    <span class=n>risk_score</span><span class=p>:</span> <span class=nb>float</span>                         <span class=c1># 风险评分</span>
</span></span><span class=line><span class=cl>    <span class=n>current_agent</span><span class=p>:</span> <span class=nb>str</span>                        <span class=c1># 当前处理人</span></span></span></code></pre></div><p><strong>关键点</strong>：使用 <code>add_messages</code> 注解，LangGraph 会自动合并消息而不是覆盖。</p><h4 id=223-step-2-创建-transfer-工具>2.2.3 Step 2: 创建 Transfer 工具<a class=anchor href=#223-step-2-%e5%88%9b%e5%bb%ba-transfer-%e5%b7%a5%e5%85%b7>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langchain_core.tools</span> <span class=kn>import</span> <span class=n>tool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>create_transfer_tool</span><span class=p>(</span><span class=n>target_agent</span><span class=p>:</span> <span class=nb>str</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;工厂函数：生成移交工具&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nd>@tool</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;transfer_to_</span><span class=si>{</span><span class=n>target_agent</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>transfer</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=sa>f</span><span class=s2>&#34;&#34;&#34;将任务移交给 </span><span class=si>{</span><span class=n>target_agent</span><span class=si>}</span><span class=s2> 继续处理。&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>target_agent</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>transfer</span></span></span></code></pre></div><p><strong>为什么这样设计</strong>？</p><ul><li>Tool 的返回值会被路由函数读取，决定下一个节点。</li><li>Tool 的 docstring 会成为 LLM 的决策依据。</li></ul><h4 id=224-step-3-定义-agent-节点>2.2.4 Step 3: 定义 Agent 节点<a class=anchor href=#224-step-3-%e5%ae%9a%e4%b9%89-agent-%e8%8a%82%e7%82%b9>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langchain_openai</span> <span class=kn>import</span> <span class=n>ChatOpenAI</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langchain_core.messages</span> <span class=kn>import</span> <span class=n>SystemMessage</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>llm</span> <span class=o>=</span> <span class=n>ChatOpenAI</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=s2>&#34;gpt-4o&#34;</span><span class=p>,</span> <span class=n>temperature</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># === Triage Agent ===</span>
</span></span><span class=line><span class=cl><span class=n>triage_tools</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>create_transfer_tool</span><span class=p>(</span><span class=s2>&#34;ClaimProcessor&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>triage_node</span><span class=p>(</span><span class=n>state</span><span class=p>:</span> <span class=n>InsuranceState</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;分流专员：收集信息并转发&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>system_msg</span> <span class=o>=</span> <span class=n>SystemMessage</span><span class=p>(</span><span class=n>content</span><span class=o>=</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    你是理赔分流专员。职责：
</span></span></span><span class=line><span class=cl><span class=s2>    1. 询问用户案件编号和基本情况
</span></span></span><span class=line><span class=cl><span class=s2>    2. 记录到系统后，调用 transfer_to_ClaimProcessor 移交
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>response</span> <span class=o>=</span> <span class=n>llm</span><span class=o>.</span><span class=n>bind_tools</span><span class=p>(</span><span class=n>triage_tools</span><span class=p>)</span><span class=o>.</span><span class=n>invoke</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=n>system_msg</span><span class=p>]</span> <span class=o>+</span> <span class=n>state</span><span class=p>[</span><span class=s2>&#34;messages&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;messages&#34;</span><span class=p>:</span> <span class=p>[</span><span class=n>response</span><span class=p>]}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># === Claim Processor ===</span>
</span></span><span class=line><span class=cl><span class=n>processor_tools</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>create_transfer_tool</span><span class=p>(</span><span class=s2>&#34;FraudDetector&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>create_transfer_tool</span><span class=p>(</span><span class=s2>&#34;LegalAdvisor&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>processor_node</span><span class=p>(</span><span class=n>state</span><span class=p>:</span> <span class=n>InsuranceState</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;初审专员：计算风险并分流&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>system_msg</span> <span class=o>=</span> <span class=n>SystemMessage</span><span class=p>(</span><span class=n>content</span><span class=o>=</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    你是理赔初审员。职责：
</span></span></span><span class=line><span class=cl><span class=s2>    1. 分析案件，计算风险评分（0-100）
</span></span></span><span class=line><span class=cl><span class=s2>    2. 如果风险 &gt; 70，调用 transfer_to_FraudDetector
</span></span></span><span class=line><span class=cl><span class=s2>    3. 否则调用 transfer_to_LegalAdvisor
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>response</span> <span class=o>=</span> <span class=n>llm</span><span class=o>.</span><span class=n>bind_tools</span><span class=p>(</span><span class=n>processor_tools</span><span class=p>)</span><span class=o>.</span><span class=n>invoke</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=n>system_msg</span><span class=p>]</span> <span class=o>+</span> <span class=n>state</span><span class=p>[</span><span class=s2>&#34;messages&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;messages&#34;</span><span class=p>:</span> <span class=p>[</span><span class=n>response</span><span class=p>]}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># === Fraud Detector ===</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fraud_node</span><span class=p>(</span><span class=n>state</span><span class=p>:</span> <span class=n>InsuranceState</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;风控专员：终端节点，不再移交&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>system_msg</span> <span class=o>=</span> <span class=n>SystemMessage</span><span class=p>(</span><span class=n>content</span><span class=o>=</span><span class=s2>&#34;你是风控专员，进行最终审核。&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>response</span> <span class=o>=</span> <span class=n>llm</span><span class=o>.</span><span class=n>invoke</span><span class=p>([</span><span class=n>system_msg</span><span class=p>]</span> <span class=o>+</span> <span class=n>state</span><span class=p>[</span><span class=s2>&#34;messages&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;messages&#34;</span><span class=p>:</span> <span class=p>[</span><span class=n>response</span><span class=p>]}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># === Legal Advisor ===</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>legal_node</span><span class=p>(</span><span class=n>state</span><span class=p>:</span> <span class=n>InsuranceState</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;法务专员：终端节点&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>system_msg</span> <span class=o>=</span> <span class=n>SystemMessage</span><span class=p>(</span><span class=n>content</span><span class=o>=</span><span class=s2>&#34;你是法务顾问，提供法律意见。&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>response</span> <span class=o>=</span> <span class=n>llm</span><span class=o>.</span><span class=n>invoke</span><span class=p>([</span><span class=n>system_msg</span><span class=p>]</span> <span class=o>+</span> <span class=n>state</span><span class=p>[</span><span class=s2>&#34;messages&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;messages&#34;</span><span class=p>:</span> <span class=p>[</span><span class=n>response</span><span class=p>]}</span></span></span></code></pre></div><h4 id=225-step-4-构建路由图>2.2.5 Step 4: 构建路由图<a class=anchor href=#225-step-4-%e6%9e%84%e5%bb%ba%e8%b7%af%e7%94%b1%e5%9b%be>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langgraph.graph</span> <span class=kn>import</span> <span class=n>StateGraph</span><span class=p>,</span> <span class=n>END</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 1. 初始化图</span>
</span></span><span class=line><span class=cl><span class=n>workflow</span> <span class=o>=</span> <span class=n>StateGraph</span><span class=p>(</span><span class=n>InsuranceState</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 添加节点</span>
</span></span><span class=line><span class=cl><span class=n>workflow</span><span class=o>.</span><span class=n>add_node</span><span class=p>(</span><span class=s2>&#34;Triage&#34;</span><span class=p>,</span> <span class=n>triage_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>workflow</span><span class=o>.</span><span class=n>add_node</span><span class=p>(</span><span class=s2>&#34;ClaimProcessor&#34;</span><span class=p>,</span> <span class=n>processor_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>workflow</span><span class=o>.</span><span class=n>add_node</span><span class=p>(</span><span class=s2>&#34;FraudDetector&#34;</span><span class=p>,</span> <span class=n>fraud_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>workflow</span><span class=o>.</span><span class=n>add_node</span><span class=p>(</span><span class=s2>&#34;LegalAdvisor&#34;</span><span class=p>,</span> <span class=n>legal_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 定义路由函数</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>router</span><span class=p>(</span><span class=n>state</span><span class=p>:</span> <span class=n>InsuranceState</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;根据最后一条消息的 Tool Call 决定路由&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>last_msg</span> <span class=o>=</span> <span class=n>state</span><span class=p>[</span><span class=s2>&#34;messages&#34;</span><span class=p>][</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 检查是否有工具调用</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>hasattr</span><span class=p>(</span><span class=n>last_msg</span><span class=p>,</span> <span class=s2>&#34;tool_calls&#34;</span><span class=p>)</span> <span class=ow>and</span> <span class=n>last_msg</span><span class=o>.</span><span class=n>tool_calls</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>tool_call</span> <span class=o>=</span> <span class=n>last_msg</span><span class=o>.</span><span class=n>tool_calls</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>tool_name</span> <span class=o>=</span> <span class=n>tool_call</span><span class=p>[</span><span class=s2>&#34;name&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 如果是 transfer_to_X 工具，返回目标节点名</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>tool_name</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=s2>&#34;transfer_to_&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>tool_name</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&#34;transfer_to_&#34;</span><span class=p>,</span> <span class=s2>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 否则结束</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>END</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 4. 添加条件边（核心机制）</span>
</span></span><span class=line><span class=cl><span class=n>workflow</span><span class=o>.</span><span class=n>add_conditional_edges</span><span class=p>(</span><span class=s2>&#34;Triage&#34;</span><span class=p>,</span> <span class=n>router</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>workflow</span><span class=o>.</span><span class=n>add_conditional_edges</span><span class=p>(</span><span class=s2>&#34;ClaimProcessor&#34;</span><span class=p>,</span> <span class=n>router</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 5. 终端节点直接结束</span>
</span></span><span class=line><span class=cl><span class=n>workflow</span><span class=o>.</span><span class=n>add_edge</span><span class=p>(</span><span class=s2>&#34;FraudDetector&#34;</span><span class=p>,</span> <span class=n>END</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>workflow</span><span class=o>.</span><span class=n>add_edge</span><span class=p>(</span><span class=s2>&#34;LegalAdvisor&#34;</span><span class=p>,</span> <span class=n>END</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 6. 设置入口</span>
</span></span><span class=line><span class=cl><span class=n>workflow</span><span class=o>.</span><span class=n>set_entry_point</span><span class=p>(</span><span class=s2>&#34;Triage&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 7. 编译</span>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>.</span><span class=n>compile</span><span class=p>()</span></span></span></code></pre></div><p><strong>关键设计点</strong>：</p><ul><li><code>add_conditional_edges(node, router)</code>：让 router 函数根据 state 决定下一步。</li><li>router 通过解析 <code>tool_calls</code> 实现动态路由。</li><li>这是 <strong>LangGraph 官方推荐的 Handoff 标准写法</strong>。</li></ul><h4 id=226-运行测试>2.2.6 运行测试<a class=anchor href=#226-%e8%bf%90%e8%a1%8c%e6%b5%8b%e8%af%95>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langchain_core.messages</span> <span class=kn>import</span> <span class=n>HumanMessage</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>app</span><span class=o>.</span><span class=n>invoke</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;messages&#34;</span><span class=p>:</span> <span class=p>[</span><span class=n>HumanMessage</span><span class=p>(</span><span class=n>content</span><span class=o>=</span><span class=s2>&#34;我要报案，案件号 C12345&#34;</span><span class=p>)],</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;claim_id&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;risk_score&#34;</span><span class=p>:</span> <span class=mf>0.0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;current_agent&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>[</span><span class=s2>&#34;messages&#34;</span><span class=p>][</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>content</span><span class=p>)</span></span></span></code></pre></div><p><strong>执行流程</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Triage: 收集信息 → 调用 transfer_to_ClaimProcessor
</span></span><span class=line><span class=cl>  ↓
</span></span><span class=line><span class=cl>ClaimProcessor: 计算风险 → 调用 transfer_to_FraudDetector
</span></span><span class=line><span class=cl>  ↓
</span></span><span class=line><span class=cl>FraudDetector: 最终审核 → END</span></span></code></pre></div><h3 id=23-swarm-模式总结>2.3 Swarm 模式总结<a class=anchor href=#23-swarm-%e6%a8%a1%e5%bc%8f%e6%80%bb%e7%bb%93>#</a></h3><p><strong>优点</strong>：</p><ul><li>状态共享零成本（内存级）</li><li>开发调试简单</li><li>适合复杂业务流程</li></ul><p><strong>局限</strong>：</p><ul><li>所有 Agent 必须在同一进程</li><li>无法跨语言、跨团队复用</li><li>受单机资源限制</li></ul><p><strong>何时使用</strong>：保险理赔、工单审批、复杂咨询等需要多角色紧密协作的场景。</p><hr><h2 id=第3章分布式协作-distributed-state>第3章：分布式协作 (Distributed State)<a class=anchor href=#%e7%ac%ac3%e7%ab%a0%e5%88%86%e5%b8%83%e5%bc%8f%e5%8d%8f%e4%bd%9c-distributed-state>#</a></h2><h3 id=31-问题swarm-的单点瓶颈>3.1 问题：Swarm 的单点瓶颈<a class=anchor href=#31-%e9%97%ae%e9%a2%98swarm-%e7%9a%84%e5%8d%95%e7%82%b9%e7%93%b6%e9%a2%88>#</a></h3><p>在上一章中，所有 Agent 必须在同一个 Python 进程里。但现实场景往往需要：</p><ul><li><strong>水平扩展</strong>：多个 Worker 处理并发请求。</li><li><strong>跨地域部署</strong>：Triage 在北京，Fraud 在上海。</li><li><strong>语言异构</strong>：Python 写的 Agent 调用 Java 写的风控服务。</li></ul><p><strong>核心挑战</strong>：如何让分布式的 Agent 共享状态？</p><h3 id=32-解决方案shared-state-via-database>3.2 解决方案：Shared State via Database<a class=anchor href=#32-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88shared-state-via-database>#</a></h3><p>LangGraph 提供了 <strong>Checkpointer</strong> 机制，将 State 持久化到外部存储。</p><pre class=mermaid>graph LR
    subgraph &#34;Worker 1 (Beijing)&#34;
        W1[Triage Agent]
    end

    subgraph &#34;Shared State&#34;
        DB[(Redis&lt;br/&gt;State Store)]
    end

    subgraph &#34;Worker 2 (Shanghai)&#34;
        W2[Fraud Agent]
    end

    W1 --&gt;|Write State| DB
    DB --&gt;|Read State| W2

    style DB fill:#ffe6e6</pre><h3 id=33-实战redis-checkpointer>3.3 实战：Redis Checkpointer<a class=anchor href=#33-%e5%ae%9e%e6%88%98redis-checkpointer>#</a></h3><h4 id=331-安装依赖>3.3.1 安装依赖<a class=anchor href=#331-%e5%ae%89%e8%a3%85%e4%be%9d%e8%b5%96>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pip install langgraph-checkpoint-redis redis</span></span></code></pre></div><h4 id=332-修改代码启用持久化>3.3.2 修改代码：启用持久化<a class=anchor href=#332-%e4%bf%ae%e6%94%b9%e4%bb%a3%e7%a0%81%e5%90%af%e7%94%a8%e6%8c%81%e4%b9%85%e5%8c%96>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langgraph.checkpoint.redis</span> <span class=kn>import</span> <span class=n>RedisSaver</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>redis</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 1. 连接 Redis</span>
</span></span><span class=line><span class=cl><span class=n>redis_client</span> <span class=o>=</span> <span class=n>redis</span><span class=o>.</span><span class=n>Redis</span><span class=p>(</span><span class=n>host</span><span class=o>=</span><span class=s2>&#34;localhost&#34;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>6379</span><span class=p>,</span> <span class=n>db</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 创建 Checkpointer</span>
</span></span><span class=line><span class=cl><span class=n>checkpointer</span> <span class=o>=</span> <span class=n>RedisSaver</span><span class=p>(</span><span class=n>redis_client</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 编译时传入</span>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>workflow</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=n>checkpointer</span><span class=o>=</span><span class=n>checkpointer</span><span class=p>)</span></span></span></code></pre></div><h4 id=333-分布式运行>3.3.3 分布式运行<a class=anchor href=#333-%e5%88%86%e5%b8%83%e5%bc%8f%e8%bf%90%e8%a1%8c>#</a></h4><p><strong>Worker 1（Triage 服务）：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># worker_triage.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fastapi</span> <span class=kn>import</span> <span class=n>FastAPI</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langserve</span> <span class=kn>import</span> <span class=n>add_routes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 只包含 Triage 节点的子图</span>
</span></span><span class=line><span class=cl><span class=n>triage_graph</span> <span class=o>=</span> <span class=n>create_triage_subgraph</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>triage_app</span> <span class=o>=</span> <span class=n>triage_graph</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=n>checkpointer</span><span class=o>=</span><span class=n>checkpointer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>api</span> <span class=o>=</span> <span class=n>FastAPI</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>add_routes</span><span class=p>(</span><span class=n>api</span><span class=p>,</span> <span class=n>triage_app</span><span class=p>,</span> <span class=n>path</span><span class=o>=</span><span class=s2>&#34;/triage&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 启动：uvicorn worker_triage:api --port 8001</span></span></span></code></pre></div><p><strong>Worker 2（Fraud 服务）：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># worker_fraud.py</span>
</span></span><span class=line><span class=cl><span class=n>fraud_graph</span> <span class=o>=</span> <span class=n>create_fraud_subgraph</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>fraud_app</span> <span class=o>=</span> <span class=n>fraud_graph</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=n>checkpointer</span><span class=o>=</span><span class=n>checkpointer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>api</span> <span class=o>=</span> <span class=n>FastAPI</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>add_routes</span><span class=p>(</span><span class=n>api</span><span class=p>,</span> <span class=n>fraud_app</span><span class=p>,</span> <span class=n>path</span><span class=o>=</span><span class=s2>&#34;/fraud&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 启动：uvicorn worker_fraud:api --port 8002</span></span></span></code></pre></div><p><strong>核心机制</strong>：</p><ol><li>Triage 处理完后，将 State 写入 Redis（thread_id 作为 key）。</li><li>Router 根据业务逻辑将请求转发到 Fraud 服务。</li><li>Fraud 服务从 Redis 读取 State，继续处理。</li></ol><h3 id=34-thread-id分布式协作的钥匙>3.4 Thread ID：分布式协作的钥匙<a class=anchor href=#34-thread-id%e5%88%86%e5%b8%83%e5%bc%8f%e5%8d%8f%e4%bd%9c%e7%9a%84%e9%92%a5%e5%8c%99>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 调用时必须指定 thread_id</span>
</span></span><span class=line><span class=cl><span class=n>config</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&#34;configurable&#34;</span><span class=p>:</span> <span class=p>{</span><span class=s2>&#34;thread_id&#34;</span><span class=p>:</span> <span class=s2>&#34;claim-12345&#34;</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Worker 1</span>
</span></span><span class=line><span class=cl><span class=n>result1</span> <span class=o>=</span> <span class=n>triage_app</span><span class=o>.</span><span class=n>invoke</span><span class=p>(</span><span class=n>input_data</span><span class=p>,</span> <span class=n>config</span><span class=o>=</span><span class=n>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Worker 2（使用相同 thread_id）</span>
</span></span><span class=line><span class=cl><span class=n>result2</span> <span class=o>=</span> <span class=n>fraud_app</span><span class=o>.</span><span class=n>invoke</span><span class=p>(</span><span class=kc>None</span><span class=p>,</span> <span class=n>config</span><span class=o>=</span><span class=n>config</span><span class=p>)</span>  <span class=c1># 自动恢复状态</span></span></span></code></pre></div><p><strong>最佳实践</strong>：</p><ul><li>使用业务 ID（如 <code>claim_id</code>）作为 thread_id。</li><li>设置 TTL，定期清理过期状态。</li></ul><h3 id=35-分布式架构图>3.5 分布式架构图<a class=anchor href=#35-%e5%88%86%e5%b8%83%e5%bc%8f%e6%9e%b6%e6%9e%84%e5%9b%be>#</a></h3><pre class=mermaid>graph TB
    User[用户请求] --&gt; Gateway[API Gateway]

    Gateway --&gt;|claim_id=12345| T[Triage Worker]
    T --&gt;|Write State| Redis[(Redis&lt;br/&gt;thread_id: 12345)]

    Gateway --&gt;|Routing| Router{Business Router}
    Router --&gt;|High Risk| F[Fraud Worker]
    Router --&gt;|Low Risk| L[Legal Worker]

    F --&gt;|Read State| Redis
    L --&gt;|Read State| Redis

    F --&gt; Result[返回结果]
    L --&gt; Result

    style Redis fill:#ff9999
    style T fill:#99ccff
    style F fill:#99ccff
    style L fill:#99ccff</pre><p><strong>这才是企业级的 Swarm</strong>：去中心化 + 分布式。</p><hr><h2 id=第4章微服务化标准-langserve>第4章：微服务化标准 (LangServe)<a class=anchor href=#%e7%ac%ac4%e7%ab%a0%e5%be%ae%e6%9c%8d%e5%8a%a1%e5%8c%96%e6%a0%87%e5%87%86-langserve>#</a></h2><h3 id=41-为什么需要-langserve>4.1 为什么需要 LangServe？<a class=anchor href=#41-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-langserve>#</a></h3><p>在分布式 Swarm 中，我们需要将 Agent 暴露为 HTTP 服务。传统做法是手写 FastAPI 路由，但这会带来问题：</p><ul><li>需要手动处理流式输出 (Streaming)</li><li>需要实现批处理 (Batch) 接口</li><li>缺乏标准化的错误处理</li><li>无法自动生成 OpenAPI 文档</li></ul><p><strong>LangServe 的价值</strong>：一行代码搞定所有。</p><h3 id=42-核心-apiadd_routes>4.2 核心 API：add_routes<a class=anchor href=#42-%e6%a0%b8%e5%bf%83-apiadd_routes>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fastapi</span> <span class=kn>import</span> <span class=n>FastAPI</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langserve</span> <span class=kn>import</span> <span class=n>add_routes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>FastAPI</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 魔法：将任何 Runnable 变成 REST API</span>
</span></span><span class=line><span class=cl><span class=n>add_routes</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>app</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>your_agent_or_chain</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>path</span><span class=o>=</span><span class=s2>&#34;/agent&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>enabled_endpoints</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;invoke&#34;</span><span class=p>,</span> <span class=s2>&#34;batch&#34;</span><span class=p>,</span> <span class=s2>&#34;stream&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>)</span></span></span></code></pre></div><p><strong>自动生成的端点</strong>：</p><ul><li><code>POST /agent/invoke</code>：同步调用</li><li><code>POST /agent/batch</code>：批量调用</li><li><code>POST /agent/stream</code>：流式输出（SSE）</li><li><code>GET /agent/playground</code>：可视化调试界面</li><li><code>GET /agent/input_schema</code>：输入 JSON Schema</li><li><code>GET /agent/output_schema</code>：输出 JSON Schema</li></ul><h3 id=43-实战暴露保险-swarm>4.3 实战：暴露保险 Swarm<a class=anchor href=#43-%e5%ae%9e%e6%88%98%e6%9a%b4%e9%9c%b2%e4%bf%9d%e9%99%a9-swarm>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># server.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fastapi</span> <span class=kn>import</span> <span class=n>FastAPI</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langserve</span> <span class=kn>import</span> <span class=n>add_routes</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>insurance_swarm</span> <span class=kn>import</span> <span class=n>app</span> <span class=k>as</span> <span class=n>swarm_app</span>  <span class=c1># 之前定义的 LangGraph</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>api</span> <span class=o>=</span> <span class=n>FastAPI</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>title</span><span class=o>=</span><span class=s2>&#34;Insurance Claims API&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>version</span><span class=o>=</span><span class=s2>&#34;1.0&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>description</span><span class=o>=</span><span class=s2>&#34;Distributed multi-agent insurance processing&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>add_routes</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>api</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>swarm_app</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>path</span><span class=o>=</span><span class=s2>&#34;/claims&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>enabled_endpoints</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;invoke&#34;</span><span class=p>,</span> <span class=s2>&#34;stream&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>uvicorn</span>
</span></span><span class=line><span class=cl>    <span class=n>uvicorn</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>api</span><span class=p>,</span> <span class=n>host</span><span class=o>=</span><span class=s2>&#34;0.0.0.0&#34;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>8000</span><span class=p>)</span></span></span></code></pre></div><p><strong>启动服务后</strong>，访问 <code>http://localhost:8000/docs</code> 即可看到完整的 API 文档。</p><h3 id=44-客户端调用remoterunnable>4.4 客户端调用：RemoteRunnable<a class=anchor href=#44-%e5%ae%a2%e6%88%b7%e7%ab%af%e8%b0%83%e7%94%a8remoterunnable>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># client.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langserve</span> <span class=kn>import</span> <span class=n>RemoteRunnable</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 连接远程服务</span>
</span></span><span class=line><span class=cl><span class=n>remote_claims</span> <span class=o>=</span> <span class=n>RemoteRunnable</span><span class=p>(</span><span class=s2>&#34;http://localhost:8000/claims&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 像调用本地函数一样</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>remote_claims</span><span class=o>.</span><span class=n>invoke</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;messages&#34;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&#34;role&#34;</span><span class=p>:</span> <span class=s2>&#34;user&#34;</span><span class=p>,</span> <span class=s2>&#34;content&#34;</span><span class=p>:</span> <span class=s2>&#34;报案编号 C9527&#34;</span><span class=p>}],</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;claim_id&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;risk_score&#34;</span><span class=p>:</span> <span class=mf>0.0</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>[</span><span class=s2>&#34;messages&#34;</span><span class=p>][</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=s2>&#34;content&#34;</span><span class=p>])</span></span></span></code></pre></div><p><strong>流式调用</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>chunk</span> <span class=ow>in</span> <span class=n>remote_claims</span><span class=o>.</span><span class=n>stream</span><span class=p>(</span><span class=n>input_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>chunk</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>,</span> <span class=n>flush</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span></span></span></code></pre></div><h3 id=45-langserve-的高级特性>4.5 LangServe 的高级特性<a class=anchor href=#45-langserve-%e7%9a%84%e9%ab%98%e7%ba%a7%e7%89%b9%e6%80%a7>#</a></h3><p><strong>1. 自动类型转换</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 服务端定义 Pydantic 模型</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ClaimInput</span><span class=p>(</span><span class=n>BaseModel</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>claim_id</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>description</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 客户端自动校验</span>
</span></span><span class=line><span class=cl><span class=n>remote_claims</span><span class=o>.</span><span class=n>invoke</span><span class=p>(</span><span class=n>ClaimInput</span><span class=p>(</span><span class=n>claim_id</span><span class=o>=</span><span class=s2>&#34;C123&#34;</span><span class=p>,</span> <span class=n>description</span><span class=o>=</span><span class=s2>&#34;车损&#34;</span><span class=p>))</span></span></span></code></pre></div><p><strong>2. LangSmith 集成</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 只需设置环境变量，LangServe 自动上报追踪数据</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s2>&#34;LANGCHAIN_TRACING_V2&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;true&#34;</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s2>&#34;LANGCHAIN_API_KEY&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;your-key&#34;</span></span></span></code></pre></div><p><strong>3. 自定义中间件</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fastapi.middleware.cors</span> <span class=kn>import</span> <span class=n>CORSMiddleware</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>app</span><span class=o>.</span><span class=n>add_middleware</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>CORSMiddleware</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>allow_origins</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;*&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>allow_methods</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;*&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>)</span></span></span></code></pre></div><h3 id=46-langserve-vs-手写-fastapi>4.6 LangServe vs 手写 FastAPI<a class=anchor href=#46-langserve-vs-%e6%89%8b%e5%86%99-fastapi>#</a></h3><table><thead><tr><th>特性</th><th>LangServe</th><th>手写 FastAPI</th></tr></thead><tbody><tr><td>开发时间</td><td>5 分钟</td><td>2 小时</td></tr><tr><td>流式输出</td><td>自动支持</td><td>需手动实现 SSE</td></tr><tr><td>批处理</td><td>自动优化</td><td>需自己写并发逻辑</td></tr><tr><td>OpenAPI 文档</td><td>自动生成</td><td>需手写装饰器</td></tr><tr><td>LangSmith 追踪</td><td>零配置</td><td>需集成 SDK</td></tr></tbody></table><p><strong>结论</strong>：除非有特殊需求（如 WebSocket、gRPC），否则应该优先使用 LangServe。</p><hr><h2 id=第5章标准化工具协议-mcp>第5章：标准化工具协议 (MCP)<a class=anchor href=#%e7%ac%ac5%e7%ab%a0%e6%a0%87%e5%87%86%e5%8c%96%e5%b7%a5%e5%85%b7%e5%8d%8f%e8%ae%ae-mcp>#</a></h2><h3 id=51-mcp-的定位>5.1 MCP 的定位<a class=anchor href=#51-mcp-%e7%9a%84%e5%ae%9a%e4%bd%8d>#</a></h3><p>在前面的章节中，我们解决了 <strong>Agent 之间的协作</strong>。但还有一个问题：<strong>如何连接外部工具</strong>？</p><p>传统做法：为每个 Agent 框架（LangChain、LlamaIndex、AutoGPT）都写一遍工具代码。</p><p><strong>MCP (Model Context Protocol)</strong> 的愿景：<strong>Write once, run anywhere.</strong></p><h3 id=52-mcp-架构原理>5.2 MCP 架构原理<a class=anchor href=#52-mcp-%e6%9e%b6%e6%9e%84%e5%8e%9f%e7%90%86>#</a></h3><pre class=mermaid>graph TB
    subgraph &#34;AI Applications&#34;
        LC[LangChain Agent]
        LI[LlamaIndex Agent]
        CC[Claude Desktop]
    end

    subgraph &#34;MCP Protocol Layer&#34;
        P[JSON-RPC 2.0]
    end

    subgraph &#34;MCP Servers&#34;
        DB[SQLite Server]
        FS[Filesystem Server]
        GH[GitHub Server]
        CUSTOM[Your Custom Server]
    end

    LC --&gt; P
    LI --&gt; P
    CC --&gt; P

    P --&gt; DB
    P --&gt; FS
    P --&gt; GH
    P --&gt; CUSTOM

    style P fill:#e1f5ff
    style DB fill:#d4f1d4
    style FS fill:#d4f1d4
    style GH fill:#d4f1d4
    style CUSTOM fill:#d4f1d4</pre><p><strong>核心概念</strong>：</p><ul><li><strong>MCP Server</strong>：独立进程，通过 stdio 或 HTTP 暴露能力。</li><li><strong>MCP Client</strong>：Agent 框架侧的适配器，负责发现和调用 Server。</li><li><strong>通信协议</strong>：基于 JSON-RPC 2.0，传输层可以是 stdio、SSE、WebSocket。</li></ul><h3 id=53-mcp-的三种原语>5.3 MCP 的三种原语<a class=anchor href=#53-mcp-%e7%9a%84%e4%b8%89%e7%a7%8d%e5%8e%9f%e8%af%ad>#</a></h3><p>MCP Server 可以暴露三种类型的能力：</p><p><strong>1. Resources（资源）</strong>：只读数据源</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@mcp.resource</span><span class=p>(</span><span class=s2>&#34;user://profile/</span><span class=si>{user_id}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_user_profile</span><span class=p>(</span><span class=n>user_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;Alice&#34;</span><span class=p>,</span> <span class=s2>&#34;age&#34;</span><span class=p>:</span> <span class=mi>30</span><span class=p>}</span></span></span></code></pre></div><p><strong>2. Tools（工具）</strong>：可执行操作</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@mcp.tool</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>send_email</span><span class=p>(</span><span class=n>to</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>subject</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>body</span><span class=p>:</span> <span class=nb>str</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;发送邮件&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 实际发送逻辑</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;Email sent&#34;</span></span></span></code></pre></div><p><strong>3. Prompts（提示词模板）</strong>：预设提示</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@mcp.prompt</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>code_review_prompt</span><span class=p>(</span><span class=n>language</span><span class=p>:</span> <span class=nb>str</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=sa>f</span><span class=s2>&#34;Review this </span><span class=si>{</span><span class=n>language</span><span class=si>}</span><span class=s2> code for security issues...&#34;</span></span></span></code></pre></div><h3 id=54-实战构建-sqlite-mcp-server>5.4 实战：构建 SQLite MCP Server<a class=anchor href=#54-%e5%ae%9e%e6%88%98%e6%9e%84%e5%bb%ba-sqlite-mcp-server>#</a></h3><h4 id=541-服务端实现>5.4.1 服务端实现<a class=anchor href=#541-%e6%9c%8d%e5%8a%a1%e7%ab%af%e5%ae%9e%e7%8e%b0>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># db_server.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>mcp.server.fastmcp</span> <span class=kn>import</span> <span class=n>FastMCP</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sqlite3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 初始化 MCP Server</span>
</span></span><span class=line><span class=cl><span class=n>mcp</span> <span class=o>=</span> <span class=n>FastMCP</span><span class=p>(</span><span class=s2>&#34;DatabaseService&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@mcp.tool</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>query_db</span><span class=p>(</span><span class=n>sql</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;执行只读 SQL 查询
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        sql: SELECT 语句（不允许 UPDATE/DELETE）
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        查询结果的 JSON 字符串
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 安全检查</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>sql</span><span class=o>.</span><span class=n>strip</span><span class=p>()</span><span class=o>.</span><span class=n>lower</span><span class=p>()</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=s2>&#34;select&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;Error: Only SELECT queries allowed&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span> <span class=o>=</span> <span class=n>sqlite3</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=s2>&#34;claims.db&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>sql</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>results</span> <span class=o>=</span> <span class=n>cursor</span><span class=o>.</span><span class=n>fetchall</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>str</span><span class=p>(</span><span class=n>results</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=sa>f</span><span class=s2>&#34;Error: </span><span class=si>{</span><span class=nb>str</span><span class=p>(</span><span class=n>e</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@mcp.resource</span><span class=p>(</span><span class=s2>&#34;db://schema&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_schema</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;获取数据库表结构&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>conn</span> <span class=o>=</span> <span class=n>sqlite3</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=s2>&#34;claims.db&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;SELECT name FROM sqlite_master WHERE type=&#39;table&#39;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tables</span> <span class=o>=</span> <span class=n>cursor</span><span class=o>.</span><span class=n>fetchall</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;tables&#34;</span><span class=p>:</span> <span class=n>tables</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>mcp</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>  <span class=c1># 默认通过 stdio 运行</span></span></span></code></pre></div><h4 id=542-客户端调用>5.4.2 客户端调用<a class=anchor href=#542-%e5%ae%a2%e6%88%b7%e7%ab%af%e8%b0%83%e7%94%a8>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># agent.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langchain_mcp_adapters.client</span> <span class=kn>import</span> <span class=n>MultiServerMCPClient</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langchain.agents</span> <span class=kn>import</span> <span class=n>create_react_agent</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langchain_openai</span> <span class=kn>import</span> <span class=n>ChatOpenAI</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 1. 连接 MCP Server</span>
</span></span><span class=line><span class=cl>    <span class=n>client</span> <span class=o>=</span> <span class=n>MultiServerMCPClient</span><span class=p>({</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;database&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;transport&#34;</span><span class=p>:</span> <span class=s2>&#34;stdio&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;command&#34;</span><span class=p>:</span> <span class=s2>&#34;python&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;args&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;db_server.py&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 2. 自动发现并加载工具</span>
</span></span><span class=line><span class=cl>    <span class=n>tools</span> <span class=o>=</span> <span class=k>await</span> <span class=n>client</span><span class=o>.</span><span class=n>get_tools</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Loaded tools: </span><span class=si>{</span><span class=p>[</span><span class=n>t</span><span class=o>.</span><span class=n>name</span> <span class=k>for</span> <span class=n>t</span> <span class=ow>in</span> <span class=n>tools</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 输出: [&#39;query_db&#39;]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 3. 创建 Agent</span>
</span></span><span class=line><span class=cl>    <span class=n>llm</span> <span class=o>=</span> <span class=n>ChatOpenAI</span><span class=p>(</span><span class=n>model</span><span class=o>=</span><span class=s2>&#34;gpt-4o&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>agent</span> <span class=o>=</span> <span class=n>create_react_agent</span><span class=p>(</span><span class=n>llm</span><span class=p>,</span> <span class=n>tools</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 4. 运行</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>agent</span><span class=o>.</span><span class=n>invoke</span><span class=p>({</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;input&#34;</span><span class=p>:</span> <span class=s2>&#34;查询 claims 表中风险评分大于 80 的案件数量&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>[</span><span class=s2>&#34;output&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span></span></span></code></pre></div><p><strong>执行流程</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Agent: &#34;需要查数据库&#34;
</span></span><span class=line><span class=cl>  → 调用 query_db 工具
</span></span><span class=line><span class=cl>  → MCP Client 通过 stdio 发送 JSON-RPC 请求到 db_server.py
</span></span><span class=line><span class=cl>  → db_server.py 执行 SQL 并返回结果
</span></span><span class=line><span class=cl>  → Agent 收到结果并生成最终回答</span></span></code></pre></div><h3 id=55-mcp-的生态优势>5.5 MCP 的生态优势<a class=anchor href=#55-mcp-%e7%9a%84%e7%94%9f%e6%80%81%e4%bc%98%e5%8a%bf>#</a></h3><p><strong>官方 MCP Servers</strong>（开箱即用）：</p><ul><li><code>@modelcontextprotocol/server-sqlite</code>：SQLite 操作</li><li><code>@modelcontextprotocol/server-filesystem</code>：文件系统访问</li><li><code>@modelcontextprotocol/server-github</code>：GitHub API</li><li><code>@modelcontextprotocol/server-brave-search</code>：搜索引擎</li></ul><p><strong>使用方法</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 安装</span>
</span></span><span class=line><span class=cl>npm install -g @modelcontextprotocol/server-github
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 配置到 Agent</span>
</span></span><span class=line><span class=cl><span class=nv>client</span> <span class=o>=</span> MultiServerMCPClient<span class=o>({</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;github&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;transport&#34;</span>: <span class=s2>&#34;stdio&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;command&#34;</span>: <span class=s2>&#34;mcp-server-github&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;env&#34;</span>: <span class=o>{</span><span class=s2>&#34;GITHUB_TOKEN&#34;</span>: <span class=s2>&#34;your-token&#34;</span><span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>})</span></span></span></code></pre></div><h3 id=56-mcp-vs-直接调用-api>5.6 MCP vs 直接调用 API<a class=anchor href=#56-mcp-vs-%e7%9b%b4%e6%8e%a5%e8%b0%83%e7%94%a8-api>#</a></h3><table><thead><tr><th>方式</th><th>MCP Server</th><th>直接调用 API</th></tr></thead><tbody><tr><td><strong>重用性</strong></td><td>一次编写，所有 Agent 框架可用</td><td>需为每个框架写一遍</td></tr><tr><td><strong>安全性</strong></td><td>Server 控制权限，Agent 无需 API Key</td><td>Agent 需持有敏感凭证</td></tr><tr><td><strong>可观测性</strong></td><td>Server 可统一记录日志</td><td>分散在各个 Agent 中</td></tr><tr><td><strong>版本管理</strong></td><td>Server 独立升级</td><td>Agent 代码耦合</td></tr></tbody></table><p><strong>最佳实践</strong>：</p><ul><li><strong>确定性工具</strong>（数据库、文件、API）→ 用 MCP</li><li><strong>推理性任务</strong>（需要多轮对话）→ 用 Swarm/LangServe</li></ul><h3 id=57-mcp-与-swarm-的协作>5.7 MCP 与 Swarm 的协作<a class=anchor href=#57-mcp-%e4%b8%8e-swarm-%e7%9a%84%e5%8d%8f%e4%bd%9c>#</a></h3><pre class=mermaid>graph TB
    subgraph &#34;Swarm Layer (内部协作)&#34;
        A1[Triage Agent]
        A2[Fraud Agent]
        A1 -.handoff.-&gt; A2
    end

    subgraph &#34;MCP Layer (工具连接)&#34;
        M1[Database MCP]
        M2[GitHub MCP]
    end

    A1 --&gt;|query_db| M1
    A2 --&gt;|create_issue| M2

    style A1 fill:#d4f1d4
    style A2 fill:#d4f1d4
    style M1 fill:#ffe6cc
    style M2 fill:#ffe6cc</pre><p><strong>设计原则</strong>：</p><ul><li>Swarm 管理内部协作逻辑</li><li>MCP 处理外部工具调用</li><li>两者通过 Tools 接口无缝集成</li></ul><hr><h2 id=第6章架构总结与选型指南>第6章：架构总结与选型指南<a class=anchor href=#%e7%ac%ac6%e7%ab%a0%e6%9e%b6%e6%9e%84%e6%80%bb%e7%bb%93%e4%b8%8e%e9%80%89%e5%9e%8b%e6%8c%87%e5%8d%97>#</a></h2><h3 id=61-技术栈对比>6.1 技术栈对比<a class=anchor href=#61-%e6%8a%80%e6%9c%af%e6%a0%88%e5%af%b9%e6%af%94>#</a></h3><table><thead><tr><th>维度</th><th>Swarm (进程内)</th><th>Distributed (Redis)</th><th>LangServe</th><th>MCP</th></tr></thead><tbody><tr><td><strong>通信方式</strong></td><td>内存共享</td><td>网络 + DB</td><td>HTTP</td><td>JSON-RPC</td></tr><tr><td><strong>延迟</strong></td><td>微秒级</td><td>毫秒级</td><td>10-100ms</td><td>5-20ms</td></tr><tr><td><strong>复杂度</strong></td><td>低</td><td>中</td><td>中</td><td>低</td></tr><tr><td><strong>扩展性</strong></td><td>单机</td><td>水平扩展</td><td>水平扩展</td><td>独立扩展</td></tr><tr><td><strong>适用场景</strong></td><td>紧密协作流程</td><td>高并发分布式</td><td>微服务架构</td><td>工具标准化</td></tr></tbody></table><h3 id=62-选型决策树>6.2 选型决策树<a class=anchor href=#62-%e9%80%89%e5%9e%8b%e5%86%b3%e7%ad%96%e6%a0%91>#</a></h3><pre class=mermaid>graph TD
    Start[开始] --&gt; Q1{是否需要调用外部工具?}
    Q1 --&gt;|是| MCP[使用 MCP Server]
    Q1 --&gt;|否| Q2{是否需要多个 Agent?}

    Q2 --&gt;|否| SingleAgent[Single Agent]
    Q2 --&gt;|是| Q3{是否需要跨语言/跨团队?}

    Q3 --&gt;|否| Q4{是否需要高并发?}
    Q3 --&gt;|是| LangServe[使用 LangServe]

    Q4 --&gt;|否| Swarm[进程内 Swarm]
    Q4 --&gt;|是| Distributed[分布式 Swarm + Redis]

    style MCP fill:#ffe6cc
    style Swarm fill:#d4f1d4
    style Distributed fill:#d4f1d4
    style LangServe fill:#e1f5ff</pre><h3 id=63-典型架构模式>6.3 典型架构模式<a class=anchor href=#63-%e5%85%b8%e5%9e%8b%e6%9e%b6%e6%9e%84%e6%a8%a1%e5%bc%8f>#</a></h3><h4 id=模式-1简单协作流程>模式 1：简单协作流程<a class=anchor href=#%e6%a8%a1%e5%bc%8f-1%e7%ae%80%e5%8d%95%e5%8d%8f%e4%bd%9c%e6%b5%81%e7%a8%8b>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>场景：在线客服（分流 → 技术支持 / 售后）
</span></span><span class=line><span class=cl>方案：进程内 Swarm
</span></span><span class=line><span class=cl>理由：流程固定，状态简单，无需分布式</span></span></code></pre></div><h4 id=模式-2高并发业务>模式 2：高并发业务<a class=anchor href=#%e6%a8%a1%e5%bc%8f-2%e9%ab%98%e5%b9%b6%e5%8f%91%e4%b8%9a%e5%8a%a1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>场景：保险理赔（每天 10 万单）
</span></span><span class=line><span class=cl>方案：分布式 Swarm (Redis Checkpointer) + LangServe
</span></span><span class=line><span class=cl>理由：需要水平扩展，异步处理</span></span></code></pre></div><h4 id=模式-3微服务生态>模式 3：微服务生态<a class=anchor href=#%e6%a8%a1%e5%bc%8f-3%e5%be%ae%e6%9c%8d%e5%8a%a1%e7%94%9f%e6%80%81>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>场景：企业 AI 中台（接入 50+ 业务系统）
</span></span><span class=line><span class=cl>方案：LangServe (Agent 服务) + MCP (工具标准化)
</span></span><span class=line><span class=cl>理由：跨团队协作，需要标准化接口</span></span></code></pre></div><h3 id=64-工程最佳实践>6.4 工程最佳实践<a class=anchor href=#64-%e5%b7%a5%e7%a8%8b%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5>#</a></h3><h4 id=1-死循环检测>1. 死循环检测<a class=anchor href=#1-%e6%ad%bb%e5%be%aa%e7%8e%af%e6%a3%80%e6%b5%8b>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>router_with_ttl</span><span class=p>(</span><span class=n>state</span><span class=p>:</span> <span class=n>InsuranceState</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 记录跳转次数</span>
</span></span><span class=line><span class=cl>    <span class=n>hop_count</span> <span class=o>=</span> <span class=n>state</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;_hop_count&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>hop_count</span> <span class=o>&gt;</span> <span class=mi>20</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>END</span>  <span class=c1># 强制终止</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 正常路由逻辑</span>
</span></span><span class=line><span class=cl>    <span class=n>next_node</span> <span class=o>=</span> <span class=n>normal_router</span><span class=p>(</span><span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>state</span><span class=p>[</span><span class=s2>&#34;_hop_count&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>hop_count</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>next_node</span></span></span></code></pre></div><h4 id=2-状态快照>2. 状态快照<a class=anchor href=#2-%e7%8a%b6%e6%80%81%e5%bf%ab%e7%85%a7>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 在关键节点保存快照，用于回滚</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>processor_node</span><span class=p>(</span><span class=n>state</span><span class=p>:</span> <span class=n>InsuranceState</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 处理前快照</span>
</span></span><span class=line><span class=cl>    <span class=n>snapshot</span> <span class=o>=</span> <span class=n>state</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 处理逻辑</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>process_claim</span><span class=p>(</span><span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 回滚</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>snapshot</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span></span></span></code></pre></div><h4 id=3-分布式追踪>3. 分布式追踪<a class=anchor href=#3-%e5%88%86%e5%b8%83%e5%bc%8f%e8%bf%bd%e8%b8%aa>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>langsmith</span> <span class=kn>import</span> <span class=n>traceable</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@traceable</span><span class=p>(</span><span class=n>run_type</span><span class=o>=</span><span class=s2>&#34;agent&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>triage_node</span><span class=p>(</span><span class=n>state</span><span class=p>:</span> <span class=n>InsuranceState</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># LangSmith 自动记录输入输出</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span></span></span></code></pre></div><p><strong>查看追踪</strong>：访问 <a href=https://smith.langchain.com>https://smith.langchain.com</a></p><h4 id=4-优雅降级>4. 优雅降级<a class=anchor href=#4-%e4%bc%98%e9%9b%85%e9%99%8d%e7%ba%a7>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>call_remote_agent_with_fallback</span><span class=p>(</span><span class=n>url</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>input_data</span><span class=p>:</span> <span class=nb>dict</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 尝试调用远程服务</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>RemoteRunnable</span><span class=p>(</span><span class=n>url</span><span class=p>)</span><span class=o>.</span><span class=n>invoke</span><span class=p>(</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 降级到本地规则</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>fallback_rule_engine</span><span class=p>(</span><span class=n>input_data</span><span class=p>)</span></span></span></code></pre></div><h3 id=65-性能优化建议>6.5 性能优化建议<a class=anchor href=#65-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e5%bb%ba%e8%ae%ae>#</a></h3><p><strong>1. Redis Checkpointer 优化</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 设置 TTL，避免内存泄漏</span>
</span></span><span class=line><span class=cl><span class=n>redis_client</span><span class=o>.</span><span class=n>setex</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=sa>f</span><span class=s2>&#34;thread:</span><span class=si>{</span><span class=n>thread_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=mi>86400</span><span class=p>,</span>  <span class=c1># 24 小时过期</span>
</span></span><span class=line><span class=cl>    <span class=n>state_json</span>
</span></span><span class=line><span class=cl><span class=p>)</span></span></span></code></pre></div><p><strong>2. LangServe 批处理</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 客户端批量调用，服务端自动并行处理</span>
</span></span><span class=line><span class=cl><span class=n>results</span> <span class=o>=</span> <span class=n>remote_agent</span><span class=o>.</span><span class=n>batch</span><span class=p>([</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s2>&#34;input&#34;</span><span class=p>:</span> <span class=s2>&#34;case 1&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s2>&#34;input&#34;</span><span class=p>:</span> <span class=s2>&#34;case 2&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s2>&#34;input&#34;</span><span class=p>:</span> <span class=s2>&#34;case 3&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>])</span></span></span></code></pre></div><p><strong>3. MCP Server 连接池</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 使用 connection pooling 复用进程</span>
</span></span><span class=line><span class=cl><span class=n>client</span> <span class=o>=</span> <span class=n>MultiServerMCPClient</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;db&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;transport&#34;</span><span class=p>:</span> <span class=s2>&#34;stdio&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;command&#34;</span><span class=p>:</span> <span class=s2>&#34;python&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;args&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;db_server.py&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;pool_size&#34;</span><span class=p>:</span> <span class=mi>5</span>  <span class=c1># 预启动 5 个进程</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>})</span></span></span></code></pre></div><h3 id=66-安全考虑>6.6 安全考虑<a class=anchor href=#66-%e5%ae%89%e5%85%a8%e8%80%83%e8%99%91>#</a></h3><p><strong>1. Agent 权限隔离</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 为不同 Agent 分配不同的 MCP Server 权限</span>
</span></span><span class=line><span class=cl><span class=n>triage_tools</span> <span class=o>=</span> <span class=k>await</span> <span class=n>client</span><span class=o>.</span><span class=n>get_tools</span><span class=p>(</span><span class=n>server</span><span class=o>=</span><span class=s2>&#34;readonly_db&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fraud_tools</span> <span class=o>=</span> <span class=k>await</span> <span class=n>client</span><span class=o>.</span><span class=n>get_tools</span><span class=p>(</span><span class=n>server</span><span class=o>=</span><span class=s2>&#34;full_access_db&#34;</span><span class=p>)</span></span></span></code></pre></div><p><strong>2. 输入验证</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pydantic</span> <span class=kn>import</span> <span class=n>BaseModel</span><span class=p>,</span> <span class=n>validator</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ClaimInput</span><span class=p>(</span><span class=n>BaseModel</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>claim_id</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@validator</span><span class=p>(</span><span class=s2>&#34;claim_id&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>validate_claim_id</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=n>v</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>v</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=s2>&#34;C&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;Invalid claim ID format&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>v</span></span></span></code></pre></div><p><strong>3. 速率限制</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fastapi_limiter</span> <span class=kn>import</span> <span class=n>FastAPILimiter</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fastapi_limiter.depends</span> <span class=kn>import</span> <span class=n>RateLimiter</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># LangServe 服务添加限流</span>
</span></span><span class=line><span class=cl><span class=nd>@app.post</span><span class=p>(</span><span class=s2>&#34;/claims/invoke&#34;</span><span class=p>,</span> <span class=n>dependencies</span><span class=o>=</span><span class=p>[</span><span class=n>Depends</span><span class=p>(</span><span class=n>RateLimiter</span><span class=p>(</span><span class=n>times</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span> <span class=n>seconds</span><span class=o>=</span><span class=mi>60</span><span class=p>))])</span></span></span></code></pre></div><hr><h2 id=结语架构的本质是控制复杂度>结语：架构的本质是控制复杂度<a class=anchor href=#%e7%bb%93%e8%af%ad%e6%9e%b6%e6%9e%84%e7%9a%84%e6%9c%ac%e8%b4%a8%e6%98%af%e6%8e%a7%e5%88%b6%e5%a4%8d%e6%9d%82%e5%ba%a6>#</a></h2><p>从吴恩达教授的四种模式到工业级的分布式 Swarm，我们学习了构建 Multi-Agent Systems 的完整路径：</p><ol><li><strong>进程内协作 (Swarm)</strong>：通过 Handoff 机制实现去中心化协作。</li><li><strong>分布式状态 (Redis Checkpointer)</strong>：突破单机限制，实现水平扩展。</li><li><strong>微服务标准 (LangServe)</strong>：一行代码将 Agent 变成 REST API。</li><li><strong>工具标准化 (MCP)</strong>：Write once, run anywhere.</li></ol><p><strong>设计原则</strong>：</p><ul><li><strong>内部用 Swarm</strong>：管理业务流程和协作逻辑。</li><li><strong>外部用 MCP</strong>：连接数据库、API、文件等工具。</li><li><strong>跨服务用 LangServe</strong>：实现微服务化和语言异构。</li></ul><p><strong>未来展望</strong>：</p><ul><li><strong>Multi-modal Agents</strong>：融合视觉、语音的多模态协作。</li><li><strong>Human-in-the-loop</strong>：在关键决策点引入人类审核。</li><li><strong>Self-evolving Swarm</strong>：Agent 通过强化学习优化协作策略。</li></ul><p>架构的本质不是技术的堆砌，而是在 <strong>复杂度、性能、可维护性</strong> 之间找到最优平衡。从 Monolith 到 Swarm 到 Ecosystem，每一步演进都应该基于真实的业务需求，而非技术炫技。</p><blockquote class=book-hint><p><strong>&ldquo;The best architecture is the one you can actually maintain.&rdquo;</strong></p><p>— Martin Fowler</p></blockquote><hr><p><strong>参考资料</strong>：</p><ul><li><a href=https://www.deeplearning.ai/the-batch/agentic-design-patterns-part-2-reflection/>Andrew Ng - Agentic Patterns</a></li><li><a href=https://langchain-ai.github.io/langgraph/concepts/multi_agent/>LangGraph Multi-Agent Documentation</a></li><li><a href=https://spec.modelcontextprotocol.io/>Model Context Protocol Specification</a></li><li><a href=https://python.langchain.com/docs/langserve>LangServe Documentation</a></li></ul></article><div style="margin-top:2rem;border-top:1px solid #e5e7eb;padding-top:1rem;font-size:.85rem;color:#6b7280;text-align:center">[统计组件仅在生产环境显示]</div><div class=giscus style=margin-top:2rem></div><script src=https://giscus.app/client.js data-repo=LordFoxFairy/LordFoxFairy.github.io data-repo-id=R_kgDOQ-JRGA data-category=Announcements data-category-id=DIC_kwDOQ-JRGM4C1PDC data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AF%87-middleware-%E5%B7%A5%E7%A8%8B%E5%8C%96/ class="flex align-center"><img src=/icons/backward.svg class=book-icon alt=Backward>
<span>第八篇 Middleware 工程化</span>
</a></span><span><a href=/notebooks/langchain%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%8D%81%E7%AF%87-%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%9B%91%E6%8E%A7%E8%AF%84%E4%BC%B0/ class="flex align-center"><span>第十篇 生产实践与监控评估</span>
<img src=/icons/forward.svg class=book-icon alt=Forward></a></span></div><div class=book-comments></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#目录导航>目录导航</a></li><li><a href=#第1章协作模式演进-patterns>第1章：协作模式演进 (Patterns)</a><ul><li><a href=#11-吴恩达的四种-agentic-模式>1.1 吴恩达的四种 Agentic 模式</a></li><li><a href=#12-架构演进从单体到生态>1.2 架构演进：从单体到生态</a></li></ul></li><li><a href=#第2章swarm-模式详解-official-way>第2章：Swarm 模式详解 (Official Way)</a><ul><li><a href=#21-核心定义swarm--蜂群算法>2.1 核心定义：Swarm ≠ 蜂群算法</a></li><li><a href=#22-官方推荐写法tool-based-routing>2.2 官方推荐写法：Tool-Based Routing</a><ul><li><a href=#221-实战场景保险理赔系统>2.2.1 实战场景：保险理赔系统</a></li><li><a href=#222-step-1-定义全局状态>2.2.2 Step 1: 定义全局状态</a></li><li><a href=#223-step-2-创建-transfer-工具>2.2.3 Step 2: 创建 Transfer 工具</a></li><li><a href=#224-step-3-定义-agent-节点>2.2.4 Step 3: 定义 Agent 节点</a></li><li><a href=#225-step-4-构建路由图>2.2.5 Step 4: 构建路由图</a></li><li><a href=#226-运行测试>2.2.6 运行测试</a></li></ul></li><li><a href=#23-swarm-模式总结>2.3 Swarm 模式总结</a></li></ul></li><li><a href=#第3章分布式协作-distributed-state>第3章：分布式协作 (Distributed State)</a><ul><li><a href=#31-问题swarm-的单点瓶颈>3.1 问题：Swarm 的单点瓶颈</a></li><li><a href=#32-解决方案shared-state-via-database>3.2 解决方案：Shared State via Database</a></li><li><a href=#33-实战redis-checkpointer>3.3 实战：Redis Checkpointer</a><ul><li><a href=#331-安装依赖>3.3.1 安装依赖</a></li><li><a href=#332-修改代码启用持久化>3.3.2 修改代码：启用持久化</a></li><li><a href=#333-分布式运行>3.3.3 分布式运行</a></li></ul></li><li><a href=#34-thread-id分布式协作的钥匙>3.4 Thread ID：分布式协作的钥匙</a></li><li><a href=#35-分布式架构图>3.5 分布式架构图</a></li></ul></li><li><a href=#第4章微服务化标准-langserve>第4章：微服务化标准 (LangServe)</a><ul><li><a href=#41-为什么需要-langserve>4.1 为什么需要 LangServe？</a></li><li><a href=#42-核心-apiadd_routes>4.2 核心 API：add_routes</a></li><li><a href=#43-实战暴露保险-swarm>4.3 实战：暴露保险 Swarm</a></li><li><a href=#44-客户端调用remoterunnable>4.4 客户端调用：RemoteRunnable</a></li><li><a href=#45-langserve-的高级特性>4.5 LangServe 的高级特性</a></li><li><a href=#46-langserve-vs-手写-fastapi>4.6 LangServe vs 手写 FastAPI</a></li></ul></li><li><a href=#第5章标准化工具协议-mcp>第5章：标准化工具协议 (MCP)</a><ul><li><a href=#51-mcp-的定位>5.1 MCP 的定位</a></li><li><a href=#52-mcp-架构原理>5.2 MCP 架构原理</a></li><li><a href=#53-mcp-的三种原语>5.3 MCP 的三种原语</a></li><li><a href=#54-实战构建-sqlite-mcp-server>5.4 实战：构建 SQLite MCP Server</a><ul><li><a href=#541-服务端实现>5.4.1 服务端实现</a></li><li><a href=#542-客户端调用>5.4.2 客户端调用</a></li></ul></li><li><a href=#55-mcp-的生态优势>5.5 MCP 的生态优势</a></li><li><a href=#56-mcp-vs-直接调用-api>5.6 MCP vs 直接调用 API</a></li><li><a href=#57-mcp-与-swarm-的协作>5.7 MCP 与 Swarm 的协作</a></li></ul></li><li><a href=#第6章架构总结与选型指南>第6章：架构总结与选型指南</a><ul><li><a href=#61-技术栈对比>6.1 技术栈对比</a></li><li><a href=#62-选型决策树>6.2 选型决策树</a></li><li><a href=#63-典型架构模式>6.3 典型架构模式</a><ul><li><a href=#模式-1简单协作流程>模式 1：简单协作流程</a></li><li><a href=#模式-2高并发业务>模式 2：高并发业务</a></li><li><a href=#模式-3微服务生态>模式 3：微服务生态</a></li></ul></li><li><a href=#64-工程最佳实践>6.4 工程最佳实践</a><ul><li><a href=#1-死循环检测>1. 死循环检测</a></li><li><a href=#2-状态快照>2. 状态快照</a></li><li><a href=#3-分布式追踪>3. 分布式追踪</a></li><li><a href=#4-优雅降级>4. 优雅降级</a></li></ul></li><li><a href=#65-性能优化建议>6.5 性能优化建议</a></li><li><a href=#66-安全考虑>6.6 安全考虑</a></li></ul></li><li><a href=#结语架构的本质是控制复杂度>结语：架构的本质是控制复杂度</a></li></ul></nav></div></aside></main></body></html>